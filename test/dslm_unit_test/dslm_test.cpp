/*
 * Copyright (c) 2022 Huawei Device Co., Ltd.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include "dslm_test.h"

#include <chrono>
#include <condition_variable>
#include <gtest/gtest.h>
#include <iostream>
#include <mutex>
#include <thread>

#include "file_ex.h"
#include "nativetoken_kit.h"
#include "securec.h"
#include "token_setproc.h"

#include "device_security_defines.h"
#include "device_security_info.h"
#include "device_security_level_defines.h"
#include "dslm_core_defines.h"
#include "dslm_core_process.h"
#include "dslm_credential.h"
#include "dslm_crypto.h"
#include "dslm_device_list.h"
#include "dslm_fsm_process.h"
#include "dslm_hidumper.h"
#include "dslm_hievent.h"
#include "dslm_inner_process.h"
#include "dslm_memory_mock.h"
#include "dslm_messenger_wrapper.h"
#include "dslm_msg_interface_mock.h"
#include "dslm_msg_serialize.h"
#include "dslm_msg_utils.h"
#include "dslm_ohos_request.h"
#include "dslm_ohos_verify.h"
#include "dslm_request_callback_mock.h"
#include "external_interface_adapter.h"
#include "messenger_device_socket_manager.h"
#include "messenger_device_status_manager.h"
#include "utils_datetime.h"
#include "utils_mem.h"
#include "utils_tlv.h"
#include "utils_work_queue.h"

using namespace std;
using namespace std::chrono;
using namespace testing;
using namespace testing::ext;

typedef struct QueueMsgData {
    DeviceIdentify srcIdentity;
    uint32_t msgLen;
    uint8_t msgData[1];
} QueueMsgData;

#define MESSENGER_PROCESS_QUEUE_SIZE 256
#define MESSENGER_PROCESS_QUEUE_NAME "messenger_queue"
#define MAX_CRED_LEN 81920
#define PTR_LEN 4
#define BUFF_LEN 8
#define MSG_BUFF_MAX_LENGTH (81920 * 4)

// for testing
extern "C" {
extern bool CheckMessage(const uint8_t *msg, uint32_t length);
extern void DoTimerProcess(TimerProc callback, const void *context);
QueueMsgData *CreateQueueMsgData(const DeviceIdentify *devId, const uint8_t *msg, uint32_t msgLen,
    uint32_t *queueDataLen);
int32_t OnPeerMsgReceived(const DeviceIdentify *devId, const uint8_t *msg, uint32_t len);
int32_t OnPeerStatusReceiver(const DeviceIdentify *deviceId, uint32_t status, int32_t level);
int32_t OnSendResultNotifier(const DeviceIdentify *devId, uint64_t transNo, uint32_t result);
}

namespace OHOS {
namespace Security {
namespace DslmUnitTest {

static uint8_t CRED[] = {0x01, 0x01, 0xa5, 0x0b, 0x30, 0x82, 0x0b, 0xa1, 0x30, 0x82, 0x0a, 0x8b, 0xa0, 0x03, 0x02, 0x01,
    0x02, 0x02, 0x01, 0x01, 0x30, 0x0b, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x0b, 0x30, 0x7f,
    0x31, 0x0b, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x43, 0x4e, 0x31, 0x13, 0x30, 0x11, 0x06, 0x03,
    0x55, 0x04, 0x08, 0x0c, 0x0a, 0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x77, 0x6f, 0x72, 0x6c, 0x64, 0x31, 0x13, 0x30, 0x11,
    0x06, 0x03, 0x55, 0x04, 0x0a, 0x0c, 0x0a, 0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x77, 0x6f, 0x72, 0x6c, 0x64, 0x31, 0x13,
    0x30, 0x11, 0x06, 0x03, 0x55, 0x04, 0x0b, 0x0c, 0x0a, 0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x77, 0x6f, 0x72, 0x6c, 0x64,
    0x31, 0x16, 0x30, 0x14, 0x06, 0x03, 0x55, 0x04, 0x03, 0x0c, 0x0d, 0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x77, 0x6f, 0x72,
    0x6c, 0x64, 0x31, 0x31, 0x31, 0x31, 0x19, 0x30, 0x17, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x09,
    0x01, 0x16, 0x0a, 0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x77, 0x6f, 0x72, 0x6c, 0x64, 0x30, 0x1e, 0x17, 0x0d, 0x32, 0x34,
    0x30, 0x34, 0x32, 0x38, 0x30, 0x39, 0x35, 0x36, 0x31, 0x32, 0x5a, 0x17, 0x0d, 0x33, 0x34, 0x30, 0x34, 0x32, 0x38,
    0x30, 0x39, 0x35, 0x36, 0x31, 0x32, 0x5a, 0x30, 0x1a, 0x31, 0x18, 0x30, 0x16, 0x06, 0x03, 0x55, 0x04, 0x03, 0x13,
    0x0f, 0x41, 0x20, 0x4b, 0x65, 0x79, 0x6d, 0x61, 0x73, 0x74, 0x65, 0x72, 0x20, 0x4b, 0x65, 0x79, 0x30, 0x82, 0x01,
    0x20, 0x30, 0x0b, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x01, 0x03, 0x82, 0x01, 0x0f, 0x00,
    0x30, 0x82, 0x01, 0x0a, 0x02, 0x82, 0x01, 0x01, 0x00, 0xc2, 0x61, 0x0a, 0xad, 0xa5, 0x33, 0xf8, 0x8f, 0x1e, 0xf3,
    0x2d, 0xf8, 0x0e, 0x4a, 0x93, 0xa2, 0xcc, 0x71, 0x85, 0xdd, 0x62, 0x0e, 0xec, 0x5e, 0xd5, 0xa7, 0xfa, 0x0b, 0x2b,
    0xdc, 0x3e, 0x9b, 0xb4, 0x06, 0xec, 0xe6, 0xea, 0x1c, 0x8f, 0x9a, 0x06, 0xfd, 0x90, 0x8f, 0xbb, 0xea, 0xe1, 0xe3,
    0x77, 0xa1, 0xd5, 0x58, 0x73, 0xae, 0xba, 0xb1, 0x68, 0xce, 0x3a, 0xa7, 0x50, 0xf0, 0x95, 0x0d, 0x24, 0x80, 0x48,
    0x06, 0xb1, 0x1b, 0x47, 0x7b, 0x09, 0x3e, 0x6a, 0xe8, 0x27, 0x33, 0x09, 0x82, 0xbb, 0x05, 0x8b, 0x88, 0x56, 0x6f,
    0xb8, 0xbe, 0x61, 0x20, 0xe4, 0x9d, 0x13, 0xbc, 0x5b, 0x96, 0x70, 0xd1, 0x56, 0xfd, 0xf7, 0x2e, 0x34, 0x41, 0x6a,
    0x02, 0xd3, 0xd9, 0xca, 0xb4, 0x2f, 0x1f, 0xf9, 0x59, 0x49, 0xf4, 0xb4, 0x04, 0x74, 0x3f, 0xe8, 0x5c, 0xc9, 0x9d,
    0x9f, 0x2d, 0x54, 0x8c, 0xe2, 0x31, 0x39, 0x5d, 0xc3, 0x39, 0xf5, 0xa1, 0xee, 0x3a, 0x2a, 0x28, 0xe1, 0xa8, 0x89,
    0x7d, 0xd6, 0x62, 0x1f, 0xc6, 0x4d, 0xd9, 0x0a, 0xc6, 0xb7, 0xae, 0x7f, 0x8d, 0xa8, 0x4a, 0x24, 0xf1, 0x4d, 0x56,
    0xba, 0xc1, 0x1d, 0xd9, 0xa8, 0x5f, 0xbb, 0xc3, 0x60, 0xd1, 0x8b, 0x01, 0xa2, 0xb4, 0x39, 0x1f, 0xa7, 0xe8, 0x67,
    0xcd, 0xd0, 0x00, 0x82, 0x37, 0xa3, 0x8b, 0xe6, 0xbb, 0x84, 0xd8, 0x71, 0xff, 0x0b, 0x3f, 0x93, 0x5a, 0x95, 0x27,
    0x56, 0x54, 0x24, 0xa2, 0x33, 0xfe, 0x24, 0x10, 0x16, 0x29, 0x3a, 0x97, 0xc2, 0x5c, 0x25, 0x0b, 0x18, 0xbd, 0x82,
    0xc2, 0x02, 0x3c, 0xf7, 0x45, 0x8c, 0x48, 0xef, 0xd4, 0x3b, 0xf8, 0xf6, 0x69, 0x3d, 0x3b, 0x96, 0xbd, 0x50, 0xff,
    0x44, 0x52, 0xba, 0x61, 0xe7, 0xaa, 0x2e, 0x5f, 0xa8, 0x4a, 0xef, 0xdc, 0xca, 0x70, 0x8e, 0xf4, 0xed, 0x9d, 0x02,
    0x03, 0x01, 0x00, 0x01, 0xa3, 0x82, 0x08, 0x91, 0x30, 0x82, 0x08, 0x8d, 0x30, 0x0b, 0x06, 0x03, 0x55, 0x1d, 0x0f,
    0x04, 0x04, 0x03, 0x02, 0x07, 0x80, 0x30, 0x08, 0x06, 0x03, 0x55, 0x1d, 0x1f, 0x04, 0x01, 0x00, 0x30, 0x82, 0x08,
    0x72, 0x06, 0x0c, 0x2b, 0x06, 0x01, 0x04, 0x01, 0x8f, 0x5b, 0x02, 0x82, 0x78, 0x01, 0x03, 0x04, 0x82, 0x08, 0x60,
    0x30, 0x82, 0x08, 0x5c, 0x02, 0x01, 0x00, 0x30, 0x72, 0x02, 0x01, 0x00, 0x06, 0x0d, 0x2b, 0x06, 0x01, 0x04, 0x01,
    0x8f, 0x5b, 0x02, 0x82, 0x78, 0x02, 0x01, 0x04, 0x04, 0x5e, 0x7b, 0x22, 0x63, 0x68, 0x61, 0x6c, 0x6c, 0x65, 0x6e,
    0x67, 0x65, 0x22, 0x3a, 0x22, 0x37, 0x38, 0x35, 0x36, 0x33, 0x34, 0x31, 0x32, 0x37, 0x38, 0x35, 0x36, 0x33, 0x34,
    0x31, 0x32, 0x22, 0x2c, 0x22, 0x70, 0x6b, 0x49, 0x6e, 0x66, 0x6f, 0x4c, 0x69, 0x73, 0x74, 0x22, 0x3a, 0x22, 0x5b,
    0x7b, 0x5c, 0x22, 0x67, 0x72, 0x6f, 0x75, 0x70, 0x49, 0x64, 0x5c, 0x22, 0x20, 0x3a, 0x20, 0x5c, 0x22, 0x30, 0x5c,
    0x22, 0x2c, 0x5c, 0x22, 0x70, 0x75, 0x62, 0x6c, 0x69, 0x63, 0x4b, 0x65, 0x79, 0x5c, 0x22, 0x20, 0x3a, 0x20, 0x5c,
    0x22, 0x30, 0x5c, 0x22, 0x7d, 0x5d, 0x22, 0x7d, 0x00, 0x30, 0x1d, 0x02, 0x01, 0x02, 0x06, 0x0d, 0x2b, 0x06, 0x01,
    0x04, 0x01, 0x8f, 0x5b, 0x02, 0x82, 0x78, 0x02, 0x01, 0x02, 0x04, 0x09, 0x64, 0x73, 0x6c, 0x6d, 0x5f, 0x6b, 0x65,
    0x79, 0x00, 0x30, 0x59, 0x02, 0x01, 0x02, 0x06, 0x0d, 0x2b, 0x06, 0x01, 0x04, 0x01, 0x8f, 0x5b, 0x02, 0x82, 0x78,
    0x02, 0x01, 0x03, 0x30, 0x45, 0x06, 0x0e, 0x2b, 0x06, 0x01, 0x04, 0x01, 0x8f, 0x5b, 0x02, 0x82, 0x78, 0x02, 0x01,
    0x03, 0x01, 0x04, 0x33, 0x7b, 0x22, 0x70, 0x72, 0x6f, 0x63, 0x65, 0x73, 0x73, 0x4e, 0x61, 0x6d, 0x65, 0x22, 0x3a,
    0x22, 0x64, 0x73, 0x6c, 0x6d, 0x5f, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x22, 0x2c, 0x22, 0x41, 0x50, 0x4c,
    0x22, 0x3a, 0x22, 0x73, 0x79, 0x73, 0x74, 0x65, 0x6d, 0x5f, 0x62, 0x61, 0x73, 0x69, 0x63, 0x22, 0x7d, 0x30, 0x16,
    0x02, 0x01, 0x03, 0x06, 0x0e, 0x2b, 0x06, 0x01, 0x04, 0x01, 0x8f, 0x5b, 0x02, 0x82, 0x78, 0x02, 0x02, 0x04, 0x0a,
    0x0c, 0x01, 0x00, 0x30, 0x82, 0x07, 0x03, 0x02, 0x01, 0x03, 0x06, 0x0e, 0x2b, 0x06, 0x01, 0x04, 0x01, 0x8f, 0x5b,
    0x02, 0x82, 0x78, 0x02, 0x02, 0x02, 0x05, 0x04, 0x82, 0x06, 0xec, 0x65, 0x79, 0x4a, 0x30, 0x65, 0x58, 0x41, 0x69,
    0x4f, 0x69, 0x41, 0x69, 0x52, 0x46, 0x4e, 0x4d, 0x49, 0x6e, 0x30, 0x3d, 0x2e, 0x65, 0x79, 0x4a, 0x30, 0x65, 0x58,
    0x42, 0x6c, 0x49, 0x6a, 0x6f, 0x67, 0x49, 0x6d, 0x52, 0x6c, 0x59, 0x6e, 0x56, 0x6e, 0x49, 0x69, 0x77, 0x67, 0x49,
    0x6d, 0x31, 0x68, 0x62, 0x6e, 0x56, 0x6d, 0x59, 0x57, 0x4e, 0x30, 0x64, 0x58, 0x4a, 0x6c, 0x49, 0x6a, 0x6f, 0x67,
    0x49, 0x6b, 0x39, 0x49, 0x54, 0x31, 0x4d, 0x69, 0x4c, 0x43, 0x41, 0x69, 0x59, 0x6e, 0x4a, 0x68, 0x62, 0x6d, 0x51,
    0x69, 0x4f, 0x69, 0x41, 0x69, 0x54, 0x30, 0x68, 0x50, 0x55, 0x79, 0x49, 0x73, 0x49, 0x43, 0x4a, 0x74, 0x62, 0x32,
    0x52, 0x6c, 0x62, 0x43, 0x49, 0x36, 0x49, 0x43, 0x4a, 0x50, 0x53, 0x45, 0x39, 0x54, 0x49, 0x69, 0x77, 0x67, 0x49,
    0x6e, 0x4e, 0x76, 0x5a, 0x6e, 0x52, 0x33, 0x59, 0x58, 0x4a, 0x6c, 0x56, 0x6d, 0x56, 0x79, 0x63, 0x32, 0x6c, 0x76,
    0x62, 0x69, 0x49, 0x36, 0x49, 0x43, 0x49, 0x7a, 0x4c, 0x6a, 0x41, 0x75, 0x4d, 0x43, 0x49, 0x73, 0x49, 0x43, 0x4a,
    0x7a, 0x5a, 0x57, 0x4e, 0x31, 0x63, 0x6d, 0x6c, 0x30, 0x65, 0x55, 0x78, 0x6c, 0x64, 0x6d, 0x56, 0x73, 0x49, 0x6a,
    0x6f, 0x67, 0x49, 0x6c, 0x4e, 0x4d, 0x4d, 0x53, 0x49, 0x73, 0x49, 0x43, 0x4a, 0x7a, 0x61, 0x57, 0x64, 0x75, 0x56,
    0x47, 0x6c, 0x74, 0x5a, 0x53, 0x49, 0x36, 0x49, 0x43, 0x49, 0x79, 0x4d, 0x44, 0x49, 0x79, 0x4d, 0x44, 0x67, 0x79,
    0x4d, 0x6a, 0x45, 0x78, 0x4e, 0x54, 0x63, 0x79, 0x4d, 0x43, 0x49, 0x73, 0x49, 0x43, 0x4a, 0x32, 0x5a, 0x58, 0x4a,
    0x7a, 0x61, 0x57, 0x39, 0x75, 0x49, 0x6a, 0x6f, 0x67, 0x49, 0x6a, 0x45, 0x75, 0x4d, 0x43, 0x34, 0x78, 0x49, 0x6e,
    0x30, 0x3d, 0x2e, 0x4d, 0x47, 0x51, 0x43, 0x4d, 0x46, 0x78, 0x6d, 0x6f, 0x75, 0x4f, 0x5a, 0x42, 0x6d, 0x43, 0x62,
    0x73, 0x34, 0x64, 0x30, 0x52, 0x76, 0x54, 0x64, 0x57, 0x4f, 0x59, 0x77, 0x53, 0x73, 0x58, 0x79, 0x44, 0x77, 0x77,
    0x62, 0x61, 0x4e, 0x58, 0x4e, 0x4d, 0x61, 0x64, 0x72, 0x6f, 0x71, 0x6d, 0x41, 0x43, 0x47, 0x64, 0x58, 0x4d, 0x59,
    0x79, 0x43, 0x30, 0x4a, 0x30, 0x2f, 0x75, 0x7a, 0x61, 0x39, 0x42, 0x42, 0x6b, 0x52, 0x2f, 0x67, 0x49, 0x77, 0x42,
    0x35, 0x5a, 0x75, 0x6d, 0x6b, 0x6d, 0x34, 0x45, 0x68, 0x66, 0x76, 0x48, 0x6f, 0x63, 0x45, 0x57, 0x6a, 0x34, 0x67,
    0x57, 0x2b, 0x61, 0x44, 0x63, 0x61, 0x6e, 0x42, 0x4d, 0x49, 0x41, 0x37, 0x33, 0x6f, 0x6e, 0x4c, 0x5a, 0x42, 0x59,
    0x71, 0x56, 0x4f, 0x73, 0x65, 0x58, 0x61, 0x4d, 0x6a, 0x7a, 0x39, 0x4f, 0x2f, 0x2f, 0x48, 0x4f, 0x58, 0x4e, 0x37,
    0x59, 0x36, 0x72, 0x30, 0x54, 0x30, 0x2e, 0x57, 0x33, 0x73, 0x69, 0x64, 0x58, 0x4e, 0x6c, 0x63, 0x6c, 0x42, 0x31,
    0x59, 0x6d, 0x78, 0x70, 0x59, 0x30, 0x74, 0x6c, 0x65, 0x53, 0x49, 0x36, 0x49, 0x43, 0x4a, 0x4e, 0x53, 0x47, 0x39,
    0x33, 0x52, 0x6b, 0x46, 0x5a, 0x53, 0x45, 0x74, 0x76, 0x57, 0x6b, 0x6c, 0x36, 0x61, 0x6a, 0x42, 0x44, 0x51, 0x56,
    0x46, 0x5a, 0x53, 0x6b, 0x74, 0x35, 0x55, 0x55, 0x52, 0x42, 0x64, 0x30, 0x6c, 0x4a, 0x51, 0x56, 0x46, 0x46, 0x54,
    0x45, 0x45, 0x79, 0x53, 0x55, 0x46, 0x43, 0x52, 0x33, 0x56, 0x4e, 0x61, 0x46, 0x56, 0x47, 0x52, 0x6d, 0x35, 0x73,
    0x55, 0x47, 0x74, 0x56, 0x64, 0x30, 0x31, 0x33, 0x64, 0x44, 0x68, 0x70, 0x51, 0x33, 0x4a, 0x50, 0x52, 0x55, 0x64,
    0x45, 0x4c, 0x30, 0x78, 0x52, 0x61, 0x55, 0x31, 0x46, 0x4d, 0x6d, 0x5a, 0x36, 0x54, 0x45, 0x30, 0x72, 0x63, 0x32,
    0x52, 0x61, 0x52, 0x58, 0x68, 0x4a, 0x4f, 0x57, 0x51, 0x78, 0x4e, 0x30, 0x52, 0x73, 0x57, 0x47, 0x68, 0x4a, 0x55,
    0x32, 0x59, 0x72, 0x57, 0x6e, 0x52, 0x7a, 0x65, 0x46, 0x52, 0x4f, 0x56, 0x44, 0x52, 0x30, 0x4e, 0x44, 0x4e, 0x44,
    0x53, 0x57, 0x31, 0x59, 0x62, 0x54, 0x6c, 0x74, 0x65, 0x6e, 0x4a, 0x4d, 0x4f, 0x54, 0x56, 0x74, 0x4f, 0x43, 0x74,
    0x4b, 0x57, 0x45, 0x4a, 0x5a, 0x53, 0x47, 0x67, 0x7a, 0x61, 0x30, 0x6c, 0x54, 0x5a, 0x45, 0x6c, 0x6e, 0x5a, 0x48,
    0x41, 0x78, 0x64, 0x56, 0x52, 0x6d, 0x62, 0x45, 0x5a, 0x49, 0x56, 0x6a, 0x42, 0x59, 0x5a, 0x6d, 0x31, 0x70, 0x59,
    0x6e, 0x67, 0x72, 0x4d, 0x6c, 0x52, 0x4d, 0x54, 0x47, 0x35, 0x51, 0x59, 0x33, 0x56, 0x58, 0x4d, 0x46, 0x42, 0x57,
    0x54, 0x58, 0x68, 0x4b, 0x4f, 0x44, 0x5a, 0x6e, 0x50, 0x54, 0x30, 0x69, 0x4c, 0x43, 0x41, 0x69, 0x63, 0x32, 0x6c,
    0x6e, 0x62, 0x6d, 0x46, 0x30, 0x64, 0x58, 0x4a, 0x6c, 0x49, 0x6a, 0x6f, 0x67, 0x49, 0x6b, 0x31, 0x48, 0x55, 0x55,
    0x4e, 0x4e, 0x51, 0x30, 0x5a, 0x34, 0x56, 0x47, 0x78, 0x6c, 0x64, 0x6a, 0x68, 0x58, 0x56, 0x6a, 0x5a, 0x6b, 0x4e,
    0x6b, 0x74, 0x75, 0x65, 0x46, 0x70, 0x79, 0x61, 0x33, 0x70, 0x52, 0x62, 0x47, 0x59, 0x33, 0x53, 0x45, 0x38, 0x35,
    0x54, 0x6d, 0x31, 0x55, 0x61, 0x33, 0x4e, 0x58, 0x65, 0x54, 0x56, 0x34, 0x61, 0x46, 0x56, 0x4f, 0x63, 0x6a, 0x6c,
    0x4d, 0x61, 0x6d, 0x6c, 0x4d, 0x63, 0x6e, 0x55, 0x33, 0x64, 0x45, 0x59, 0x31, 0x65, 0x6d, 0x59, 0x72, 0x4d, 0x45,
    0x4a, 0x5a, 0x65, 0x47, 0x35, 0x32, 0x57, 0x58, 0x67, 0x79, 0x62, 0x56, 0x46, 0x4a, 0x64, 0x32, 0x4e, 0x68, 0x65,
    0x6e, 0x56, 0x74, 0x64, 0x30, 0x64, 0x73, 0x61, 0x47, 0x78, 0x4f, 0x52, 0x48, 0x67, 0x72, 0x5a, 0x48, 0x4a, 0x30,
    0x5a, 0x30, 0x4a, 0x7a, 0x53, 0x48, 0x46, 0x4c, 0x63, 0x6b, 0x64, 0x71, 0x63, 0x57, 0x52, 0x45, 0x4e, 0x44, 0x4e,
    0x54, 0x62, 0x44, 0x6b, 0x7a, 0x52, 0x33, 0x42, 0x33, 0x4e, 0x45, 0x38, 0x33, 0x55, 0x6b, 0x35, 0x52, 0x55, 0x7a,
    0x4a, 0x51, 0x64, 0x6e, 0x67, 0x34, 0x53, 0x6d, 0x74, 0x4b, 0x59, 0x6e, 0x52, 0x46, 0x56, 0x57, 0x56, 0x79, 0x5a,
    0x48, 0x59, 0x76, 0x4e, 0x56, 0x4d, 0x69, 0x66, 0x53, 0x77, 0x67, 0x65, 0x79, 0x4a, 0x31, 0x63, 0x32, 0x56, 0x79,
    0x55, 0x48, 0x56, 0x69, 0x62, 0x47, 0x6c, 0x6a, 0x53, 0x32, 0x56, 0x35, 0x49, 0x6a, 0x6f, 0x67, 0x49, 0x6b, 0x31,
    0x49, 0x62, 0x33, 0x64, 0x47, 0x51, 0x56, 0x6c, 0x49, 0x53, 0x32, 0x39, 0x61, 0x53, 0x58, 0x70, 0x71, 0x4d, 0x45,
    0x4e, 0x42, 0x55, 0x56, 0x6c, 0x4b, 0x53, 0x33, 0x6c, 0x52, 0x52, 0x45, 0x46, 0x33, 0x53, 0x55, 0x6c, 0x42, 0x55,
    0x55, 0x56, 0x4d, 0x51, 0x54, 0x4a, 0x4a, 0x51, 0x55, 0x4a, 0x46, 0x51, 0x6b, 0x46, 0x47, 0x57, 0x54, 0x6b, 0x72,
    0x4d, 0x30, 0x52, 0x61, 0x54, 0x48, 0x4d, 0x34, 0x54, 0x6e, 0x52, 0x61, 0x52, 0x48, 0x56, 0x73, 0x5a, 0x48, 0x52,
    0x77, 0x51, 0x6d, 0x70, 0x31, 0x61, 0x6c, 0x42, 0x32, 0x64, 0x32, 0x6c, 0x6c, 0x55, 0x44, 0x6c, 0x55, 0x64, 0x6b,
    0x31, 0x50, 0x57, 0x46, 0x5a, 0x72, 0x4e, 0x57, 0x5a, 0x32, 0x53, 0x6b, 0x68, 0x46, 0x55, 0x58, 0x59, 0x32, 0x57,
    0x45, 0x52, 0x6c, 0x62, 0x45, 0x64, 0x50, 0x4e, 0x47, 0x52, 0x6e, 0x55, 0x56, 0x6f, 0x7a, 0x4e, 0x6c, 0x56, 0x4b,
    0x51, 0x32, 0x6c, 0x56, 0x64, 0x31, 0x55, 0x79, 0x4c, 0x33, 0x4a, 0x4c, 0x63, 0x6b, 0x4e, 0x72, 0x65, 0x6e, 0x46,
    0x76, 0x53, 0x30, 0x74, 0x74, 0x61, 0x58, 0x4e, 0x4e, 0x61, 0x30, 0x59, 0x32, 0x61, 0x46, 0x46, 0x6e, 0x62, 0x6c,
    0x5a, 0x46, 0x5a, 0x33, 0x6c, 0x33, 0x61, 0x33, 0x68, 0x61, 0x56, 0x32, 0x34, 0x7a, 0x61, 0x48, 0x46, 0x6a, 0x65,
    0x6e, 0x67, 0x7a, 0x63, 0x44, 0x64, 0x7a, 0x61, 0x6d, 0x46, 0x32, 0x53, 0x33, 0x6c, 0x53, 0x59, 0x6e, 0x52, 0x58,
    0x56, 0x57, 0x35, 0x58, 0x64, 0x6d, 0x74, 0x54, 0x56, 0x32, 0x63, 0x39, 0x50, 0x53, 0x49, 0x73, 0x49, 0x43, 0x4a,
    0x7a, 0x61, 0x57, 0x64, 0x75, 0x59, 0x58, 0x52, 0x31, 0x63, 0x6d, 0x55, 0x69, 0x4f, 0x69, 0x41, 0x69, 0x54, 0x55,
    0x64, 0x52, 0x51, 0x30, 0x31, 0x47, 0x55, 0x32, 0x4a, 0x48, 0x4d, 0x7a, 0x64, 0x4d, 0x63, 0x30, 0x64, 0x7a, 0x52,
    0x6b, 0x70, 0x4c, 0x5a, 0x31, 0x6c, 0x44, 0x56, 0x55, 0x52, 0x30, 0x53, 0x33, 0x42, 0x74, 0x51, 0x33, 0x46, 0x56,
    0x52, 0x48, 0x63, 0x31, 0x63, 0x6b, 0x31, 0x4d, 0x56, 0x6b, 0x68, 0x6a, 0x51, 0x33, 0x5a, 0x74, 0x61, 0x44, 0x56,
    0x68, 0x63, 0x56, 0x68, 0x72, 0x51, 0x6d, 0x51, 0x32, 0x52, 0x7a, 0x6c, 0x7a, 0x55, 0x44, 0x5a, 0x47, 0x64, 0x30,
    0x52, 0x71, 0x62, 0x6d, 0x64, 0x59, 0x65, 0x45, 0x74, 0x73, 0x51, 0x31, 0x52, 0x4d, 0x5a, 0x30, 0x6c, 0x33, 0x5a,
    0x48, 0x56, 0x34, 0x64, 0x45, 0x67, 0x30, 0x59, 0x55, 0x51, 0x35, 0x52, 0x6a, 0x4e, 0x33, 0x54, 0x30, 0x74, 0x51,
    0x4e, 0x6e, 0x5a, 0x4a, 0x4d, 0x31, 0x46, 0x76, 0x63, 0x56, 0x4e, 0x6e, 0x65, 0x57, 0x4a, 0x49, 0x4d, 0x6b, 0x5a,
    0x6a, 0x64, 0x79, 0x74, 0x46, 0x59, 0x33, 0x6f, 0x32, 0x4d, 0x6b, 0x30, 0x33, 0x54, 0x30, 0x52, 0x74, 0x4e, 0x30,
    0x70, 0x33, 0x52, 0x57, 0x52, 0x6d, 0x5a, 0x58, 0x6f, 0x77, 0x53, 0x6b, 0x4a, 0x31, 0x59, 0x30, 0x64, 0x4b, 0x4d,
    0x30, 0x68, 0x4b, 0x5a, 0x58, 0x56, 0x56, 0x56, 0x79, 0x4a, 0x39, 0x4c, 0x43, 0x42, 0x37, 0x49, 0x6e, 0x56, 0x7a,
    0x5a, 0x58, 0x4a, 0x51, 0x64, 0x57, 0x4a, 0x73, 0x61, 0x57, 0x4e, 0x4c, 0x5a, 0x58, 0x6b, 0x69, 0x4f, 0x69, 0x41,
    0x69, 0x54, 0x55, 0x68, 0x76, 0x64, 0x30, 0x5a, 0x42, 0x57, 0x55, 0x68, 0x4c, 0x62, 0x31, 0x70, 0x4a, 0x65, 0x6d,
    0x6f, 0x77, 0x51, 0x30, 0x46, 0x52, 0x57, 0x55, 0x70, 0x4c, 0x65, 0x56, 0x46, 0x45, 0x51, 0x58, 0x64, 0x4a, 0x53,
    0x55, 0x46, 0x52, 0x52, 0x55, 0x78, 0x42, 0x4d, 0x6b, 0x6c, 0x42, 0x51, 0x6b, 0x52, 0x46, 0x4d, 0x48, 0x4e, 0x50,
    0x4d, 0x55, 0x56, 0x57, 0x63, 0x58, 0x56, 0x69, 0x55, 0x48, 0x4d, 0x78, 0x62, 0x44, 0x4e, 0x61, 0x64, 0x6d, 0x70,
    0x42, 0x54, 0x45, 0x35, 0x78, 0x52, 0x6b, 0x63, 0x72, 0x55, 0x6c, 0x42, 0x49, 0x65, 0x69, 0x39, 0x4e, 0x4b, 0x33,
    0x52, 0x50, 0x65, 0x55, 0x4e, 0x36, 0x63, 0x54, 0x4a, 0x75, 0x4e, 0x55, 0x46, 0x4e, 0x52, 0x6e, 0x55, 0x72, 0x4d,
    0x57, 0x78, 0x73, 0x55, 0x45, 0x46, 0x68, 0x56, 0x45, 0x64, 0x59, 0x59, 0x7a, 0x51, 0x77, 0x54, 0x79, 0x39, 0x75,
    0x54, 0x47, 0x6c, 0x75, 0x65, 0x69, 0x38, 0x34, 0x65, 0x6d, 0x5a, 0x61, 0x4e, 0x48, 0x52, 0x45, 0x51, 0x57, 0x6c,
    0x55, 0x62, 0x33, 0x4e, 0x42, 0x55, 0x6d, 0x6c, 0x4b, 0x4b, 0x32, 0x30, 0x7a, 0x63, 0x6b, 0x56, 0x57, 0x54, 0x55,
    0x5a, 0x72, 0x51, 0x69, 0x74, 0x6d, 0x62, 0x6e, 0x68, 0x35, 0x53, 0x45, 0x46, 0x44, 0x63, 0x32, 0x55, 0x72, 0x59,
    0x57, 0x70, 0x48, 0x64, 0x6d, 0x5a, 0x78, 0x5a, 0x32, 0x46, 0x32, 0x61, 0x6a, 0x6c, 0x47, 0x54, 0x58, 0x4e, 0x49,
    0x59, 0x6a, 0x4a, 0x4d, 0x52, 0x56, 0x70, 0x51, 0x5a, 0x6d, 0x6b, 0x72, 0x64, 0x7a, 0x30, 0x39, 0x49, 0x69, 0x77,
    0x67, 0x49, 0x6e, 0x4e, 0x70, 0x5a, 0x32, 0x35, 0x68, 0x64, 0x48, 0x56, 0x79, 0x5a, 0x53, 0x49, 0x36, 0x49, 0x43,
    0x4a, 0x4e, 0x52, 0x30, 0x31, 0x44, 0x54, 0x55, 0x56, 0x30, 0x64, 0x44, 0x63, 0x31, 0x56, 0x47, 0x30, 0x77, 0x55,
    0x6d, 0x64, 0x74, 0x59, 0x6c, 0x6b, 0x76, 0x62, 0x32, 0x56, 0x70, 0x62, 0x30, 0x59, 0x33, 0x63, 0x48, 0x63, 0x32,
    0x4b, 0x32, 0x38, 0x76, 0x5a, 0x45, 0x4a, 0x6d, 0x57, 0x54, 0x46, 0x43, 0x56, 0x56, 0x52, 0x30, 0x52, 0x48, 0x6c,
    0x56, 0x62, 0x6a, 0x46, 0x79, 0x57, 0x6a, 0x6c, 0x74, 0x54, 0x57, 0x31, 0x4e, 0x57, 0x47, 0x78, 0x79, 0x51, 0x30,
    0x6f, 0x76, 0x61, 0x47, 0x46, 0x54, 0x63, 0x32, 0x35, 0x6f, 0x53, 0x47, 0x31, 0x32, 0x64, 0x32, 0x68, 0x33, 0x53,
    0x58, 0x5a, 0x6d, 0x59, 0x54, 0x42, 0x54, 0x5a, 0x30, 0x67, 0x7a, 0x57, 0x45, 0x4e, 0x42, 0x62, 0x55, 0x52, 0x55,
    0x57, 0x6d, 0x30, 0x78, 0x4d, 0x6e, 0x70, 0x54, 0x55, 0x48, 0x63, 0x34, 0x62, 0x31, 0x6c, 0x49, 0x4c, 0x33, 0x51,
    0x76, 0x4e, 0x58, 0x46, 0x30, 0x53, 0x30, 0x74, 0x48, 0x64, 0x6c, 0x70, 0x46, 0x5a, 0x57, 0x4a, 0x6d, 0x53, 0x6c,
    0x64, 0x49, 0x51, 0x56, 0x45, 0x35, 0x4d, 0x46, 0x70, 0x6e, 0x62, 0x6c, 0x68, 0x55, 0x64, 0x57, 0x4e, 0x4f, 0x52,
    0x30, 0x46, 0x51, 0x59, 0x30, 0x35, 0x42, 0x4f, 0x45, 0x6b, 0x39, 0x49, 0x6e, 0x31, 0x64, 0x00, 0x30, 0x18, 0x02,
    0x01, 0x02, 0x06, 0x0d, 0x2b, 0x06, 0x01, 0x04, 0x01, 0x8f, 0x5b, 0x02, 0x82, 0x78, 0x02, 0x01, 0x0b, 0x04, 0x04,
    0x00, 0x00, 0x00, 0x00, 0x30, 0x18, 0x02, 0x01, 0x02, 0x06, 0x0d, 0x2b, 0x06, 0x01, 0x04, 0x01, 0x8f, 0x5b, 0x02,
    0x82, 0x78, 0x02, 0x01, 0x05, 0x04, 0x04, 0x02, 0x00, 0x00, 0x00, 0x30, 0x16, 0x02, 0x01, 0x02, 0x06, 0x0e, 0x2b,
    0x06, 0x01, 0x04, 0x01, 0x8f, 0x5b, 0x02, 0x82, 0x78, 0x02, 0x04, 0x01, 0x03, 0x01, 0x01, 0xff, 0x30, 0x0b, 0x06,
    0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x0b, 0x03, 0x82, 0x01, 0x01, 0x00, 0x8d, 0xb8, 0xee, 0xa7,
    0x12, 0x30, 0x8c, 0x48, 0xc0, 0x57, 0x26, 0x99, 0xed, 0x1b, 0x48, 0x93, 0xdd, 0x7c, 0x7f, 0x04, 0xbd, 0x8b, 0x2a,
    0x70, 0x2d, 0x27, 0x02, 0x8d, 0x98, 0xf0, 0x27, 0x78, 0xc2, 0x10, 0x1e, 0xa9, 0x5a, 0x3d, 0xce, 0x7b, 0x0d, 0x16,
    0x57, 0x33, 0xd4, 0x5b, 0x87, 0x79, 0x65, 0xf0, 0x6f, 0xc4, 0xb0, 0x61, 0xef, 0x04, 0xa5, 0x6e, 0xd6, 0xc5, 0xbe,
    0xf1, 0xbe, 0x6d, 0xaf, 0x76, 0x6f, 0x88, 0xc1, 0x37, 0xe8, 0xcd, 0x9d, 0x11, 0xdf, 0x57, 0x79, 0xc9, 0x74, 0x9e,
    0x91, 0x8c, 0xb6, 0x82, 0x8a, 0xc7, 0x82, 0x5c, 0x25, 0x68, 0x90, 0x70, 0x9a, 0x31, 0x4e, 0x06, 0x7d, 0x57, 0x57,
    0x26, 0x60, 0x09, 0x52, 0xf5, 0x4e, 0x6c, 0xee, 0xd8, 0x6b, 0x36, 0x80, 0x35, 0x21, 0xa9, 0xb2, 0x7a, 0x6b, 0x26,
    0x4c, 0x44, 0xbd, 0xb6, 0x37, 0x27, 0x66, 0xe8, 0x26, 0x12, 0x51, 0xd2, 0x5b, 0x85, 0x3e, 0x92, 0x5a, 0xd3, 0x9d,
    0xca, 0xc5, 0x92, 0xcb, 0x13, 0xa0, 0x8a, 0x52, 0xb7, 0xa7, 0xf3, 0x2b, 0xdc, 0x6d, 0x65, 0xf0, 0xb6, 0x52, 0xbc,
    0xf7, 0x40, 0xdc, 0x8e, 0xa8, 0x6b, 0xda, 0xbc, 0x6a, 0xb4, 0x50, 0x63, 0x20, 0xe4, 0x34, 0xf4, 0x59, 0xaa, 0x88,
    0xdc, 0xe3, 0x7a, 0x88, 0xde, 0xcd, 0xd6, 0xb6, 0x0c, 0x19, 0xfc, 0x1f, 0xe2, 0x47, 0xae, 0x35, 0xcf, 0x91, 0x7e,
    0x7b, 0x05, 0x9f, 0x7b, 0x27, 0x80, 0x25, 0x21, 0x06, 0x43, 0xa0, 0x28, 0xb0, 0xa2, 0x71, 0xda, 0xc8, 0x63, 0xed,
    0x7d, 0x58, 0x2e, 0x20, 0xfc, 0xde, 0x00, 0x1a, 0x04, 0xba, 0xcc, 0x5f, 0x78, 0x99, 0x64, 0xa5, 0x65, 0x2f, 0x10,
    0x7b, 0x98, 0xc0, 0x36, 0x4a, 0x5f, 0x82, 0xe6, 0x77, 0x81, 0x13, 0xda, 0xa0, 0x21, 0xec, 0x80, 0x0f, 0x46, 0x12,
    0x13, 0x50, 0xdd, 0xe6, 0xee, 0x01, 0x01, 0xcf, 0x03, 0x30, 0x82, 0x03, 0xcb, 0x30, 0x82, 0x02, 0xb3, 0xa0, 0x03,
    0x02, 0x01, 0x02, 0x02, 0x01, 0x03, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x0b,
    0x05, 0x00, 0x30, 0x7e, 0x31, 0x0b, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x43, 0x4e, 0x31, 0x13,
    0x30, 0x11, 0x06, 0x03, 0x55, 0x04, 0x08, 0x0c, 0x0a, 0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x77, 0x6f, 0x72, 0x6c, 0x64,
    0x31, 0x13, 0x30, 0x11, 0x06, 0x03, 0x55, 0x04, 0x0a, 0x0c, 0x0a, 0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x77, 0x6f, 0x72,
    0x6c, 0x64, 0x31, 0x13, 0x30, 0x11, 0x06, 0x03, 0x55, 0x04, 0x0b, 0x0c, 0x0a, 0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x77,
    0x6f, 0x72, 0x6c, 0x64, 0x31, 0x15, 0x30, 0x13, 0x06, 0x03, 0x55, 0x04, 0x03, 0x0c, 0x0c, 0x68, 0x65, 0x6c, 0x6c,
    0x6f, 0x77, 0x6f, 0x72, 0x6c, 0x64, 0x31, 0x31, 0x31, 0x19, 0x30, 0x17, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7,
    0x0d, 0x01, 0x09, 0x01, 0x16, 0x0a, 0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x77, 0x6f, 0x72, 0x6c, 0x64, 0x30, 0x1e, 0x17,
    0x0d, 0x32, 0x32, 0x30, 0x31, 0x32, 0x32, 0x30, 0x39, 0x32, 0x35, 0x33, 0x33, 0x5a, 0x17, 0x0d, 0x33, 0x32, 0x30,
    0x31, 0x32, 0x30, 0x30, 0x39, 0x32, 0x35, 0x33, 0x33, 0x5a, 0x30, 0x7f, 0x31, 0x0b, 0x30, 0x09, 0x06, 0x03, 0x55,
    0x04, 0x06, 0x13, 0x02, 0x43, 0x4e, 0x31, 0x13, 0x30, 0x11, 0x06, 0x03, 0x55, 0x04, 0x08, 0x0c, 0x0a, 0x68, 0x65,
    0x6c, 0x6c, 0x6f, 0x77, 0x6f, 0x72, 0x6c, 0x64, 0x31, 0x13, 0x30, 0x11, 0x06, 0x03, 0x55, 0x04, 0x0a, 0x0c, 0x0a,
    0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x77, 0x6f, 0x72, 0x6c, 0x64, 0x31, 0x13, 0x30, 0x11, 0x06, 0x03, 0x55, 0x04, 0x0b,
    0x0c, 0x0a, 0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x77, 0x6f, 0x72, 0x6c, 0x64, 0x31, 0x16, 0x30, 0x14, 0x06, 0x03, 0x55,
    0x04, 0x03, 0x0c, 0x0d, 0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x77, 0x6f, 0x72, 0x6c, 0x64, 0x31, 0x31, 0x31, 0x31, 0x19,
    0x30, 0x17, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x09, 0x01, 0x16, 0x0a, 0x68, 0x65, 0x6c, 0x6c,
    0x6f, 0x77, 0x6f, 0x72, 0x6c, 0x64, 0x30, 0x82, 0x01, 0x22, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7,
    0x0d, 0x01, 0x01, 0x01, 0x05, 0x00, 0x03, 0x82, 0x01, 0x0f, 0x00, 0x30, 0x82, 0x01, 0x0a, 0x02, 0x82, 0x01, 0x01,
    0x00, 0xbc, 0x1c, 0x78, 0x55, 0x11, 0xb6, 0x37, 0xba, 0xea, 0xe2, 0x5b, 0x7c, 0x00, 0x70, 0x03, 0x05, 0xc0, 0x85,
    0x1d, 0xf9, 0x52, 0x26, 0x01, 0x42, 0xa7, 0x58, 0x06, 0x25, 0xb2, 0x21, 0xcb, 0x3e, 0xcd, 0xc1, 0x86, 0x91, 0xc7,
    0x6f, 0xae, 0xe4, 0x8f, 0x33, 0xf7, 0xad, 0xc4, 0x1b, 0x67, 0x69, 0x75, 0x2d, 0x23, 0x16, 0x8e, 0x85, 0x7c, 0x8d,
    0x77, 0x24, 0x54, 0xc3, 0x85, 0xa8, 0xe9, 0x53, 0x96, 0xb6, 0x25, 0x18, 0xcd, 0xc6, 0xf3, 0x46, 0xd5, 0x69, 0x67,
    0x04, 0x83, 0x0e, 0x1c, 0xfa, 0x79, 0x12, 0x93, 0xe0, 0x29, 0x1a, 0x63, 0x54, 0x6b, 0xaf, 0x47, 0x2b, 0x78, 0x7e,
    0xe6, 0xf7, 0xf3, 0xf3, 0x57, 0xd5, 0x98, 0x92, 0xf5, 0xcd, 0x7d, 0x15, 0x69, 0x88, 0x80, 0xfb, 0x00, 0xb3, 0xac,
    0x57, 0x35, 0xc3, 0x96, 0x86, 0x2a, 0x1b, 0x05, 0x21, 0xc2, 0x18, 0xf0, 0x55, 0x28, 0x8b, 0x5e, 0x71, 0xaf, 0x00,
    0x14, 0x45, 0x0f, 0xbf, 0x13, 0x29, 0x73, 0x78, 0x5d, 0xf4, 0xda, 0xa1, 0xb0, 0x90, 0x21, 0xd8, 0xcb, 0x8c, 0xd0,
    0xaa, 0x7d, 0xe8, 0x86, 0x4b, 0xb6, 0xe6, 0xb3, 0xcb, 0x50, 0xec, 0x8e, 0xa7, 0xa8, 0x09, 0x36, 0xcf, 0xf7, 0x05,
    0x58, 0x7b, 0xe9, 0xbf, 0x7f, 0xd6, 0x24, 0xf2, 0x3f, 0xb9, 0x5d, 0x0c, 0x3e, 0xd5, 0x57, 0x85, 0x10, 0x09, 0x30,
    0xe9, 0xa4, 0x5b, 0x6b, 0x0d, 0x06, 0x3f, 0x52, 0xb0, 0x61, 0x7b, 0xdb, 0x0f, 0x9f, 0x4f, 0xba, 0x19, 0x60, 0x5f,
    0x92, 0x48, 0xf3, 0xe6, 0x7d, 0x5a, 0x18, 0x4e, 0xc9, 0x3f, 0x6b, 0xe6, 0x07, 0x7a, 0x8c, 0x83, 0x12, 0x29, 0x12,
    0x49, 0x95, 0x2d, 0x52, 0x31, 0x87, 0xa7, 0x70, 0x04, 0xe9, 0xad, 0xaf, 0xeb, 0x13, 0xef, 0x12, 0x7e, 0x53, 0x39,
    0x93, 0x59, 0xb6, 0xe1, 0x34, 0x60, 0xa4, 0xcd, 0x23, 0xf1, 0x02, 0x03, 0x01, 0x00, 0x01, 0xa3, 0x53, 0x30, 0x51,
    0x30, 0x1d, 0x06, 0x03, 0x55, 0x1d, 0x0e, 0x04, 0x16, 0x04, 0x14, 0x83, 0x4e, 0xaa, 0x7a, 0x40, 0xe7, 0x71, 0x93,
    0xdc, 0xc5, 0xd8, 0x7f, 0xbb, 0x20, 0x63, 0x9c, 0x92, 0xaf, 0xc0, 0xd4, 0x30, 0x1f, 0x06, 0x03, 0x55, 0x1d, 0x23,
    0x04, 0x18, 0x30, 0x16, 0x80, 0x14, 0x4d, 0x60, 0x01, 0x09, 0x97, 0x0c, 0x4f, 0x3a, 0x3e, 0x45, 0x07, 0xb3, 0x38,
    0x99, 0x3b, 0x0c, 0xa6, 0x89, 0x11, 0x2f, 0x30, 0x0f, 0x06, 0x03, 0x55, 0x1d, 0x13, 0x01, 0x01, 0xff, 0x04, 0x05,
    0x30, 0x03, 0x01, 0x01, 0xff, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x0b, 0x05,
    0x00, 0x03, 0x82, 0x01, 0x01, 0x00, 0x78, 0x0a, 0x42, 0x9b, 0x25, 0x05, 0xae, 0x0b, 0x6a, 0x63, 0xd1, 0xc4, 0xbe,
    0xcd, 0xbe, 0x2f, 0xf1, 0xf4, 0x6a, 0xf0, 0xe3, 0xe3, 0x45, 0x53, 0xf2, 0x96, 0xa8, 0xc7, 0x5f, 0x82, 0x0c, 0xa6,
    0x69, 0xe5, 0xd9, 0x53, 0x34, 0x0e, 0x43, 0x57, 0x0f, 0x44, 0x98, 0x3c, 0x2e, 0x48, 0xc6, 0x42, 0xb8, 0x6e, 0x0b,
    0x60, 0x94, 0x6d, 0x11, 0x92, 0xbe, 0x1b, 0x95, 0x87, 0xfe, 0x3d, 0xd3, 0x5e, 0x9d, 0xb7, 0x9b, 0x59, 0x9b, 0xf0,
    0xe1, 0x8d, 0xc9, 0x52, 0x84, 0x20, 0x49, 0xab, 0x1f, 0x74, 0x80, 0x3f, 0xac, 0x95, 0xd9, 0xb5, 0xfd, 0xe6, 0x55,
    0x43, 0x4b, 0x98, 0xf9, 0x5c, 0x45, 0x66, 0x42, 0x3a, 0xd1, 0x89, 0x9a, 0xf9, 0x67, 0xb6, 0x9e, 0xff, 0xa9, 0x69,
    0x7b, 0x24, 0x22, 0x1a, 0x88, 0x3e, 0xf7, 0xd9, 0xb6, 0x89, 0x53, 0x50, 0xd9, 0x72, 0x1c, 0xb7, 0x6a, 0x6d, 0x96,
    0x58, 0x6a, 0x5c, 0x84, 0x11, 0x12, 0x04, 0xeb, 0x68, 0x4a, 0xf7, 0x72, 0xc0, 0x6f, 0x93, 0xd3, 0x14, 0x10, 0x71,
    0x7c, 0xd8, 0x43, 0xe9, 0x87, 0x3e, 0xcc, 0xa6, 0xdf, 0x42, 0x42, 0xcc, 0x28, 0x6f, 0x64, 0x22, 0xb3, 0xf9, 0x02,
    0x65, 0x21, 0x95, 0x09, 0xdd, 0x78, 0x28, 0x28, 0x7e, 0xcc, 0x56, 0xf8, 0x80, 0x49, 0x71, 0x9c, 0x58, 0xb2, 0x8e,
    0x05, 0x86, 0x14, 0x0e, 0xdd, 0xc9, 0xf3, 0xf3, 0xcc, 0xb2, 0x16, 0xec, 0xa9, 0xbf, 0xab, 0x9b, 0xe5, 0x6a, 0x53,
    0x9a, 0x21, 0x57, 0xc4, 0x6b, 0xfe, 0x74, 0x3e, 0x40, 0xbb, 0xc4, 0x15, 0xaf, 0x2b, 0xaf, 0x3e, 0xea, 0x63, 0xaf,
    0xf6, 0x41, 0x26, 0xd4, 0xcb, 0xb4, 0x2f, 0x14, 0x2b, 0xfb, 0x31, 0x71, 0x43, 0xd6, 0x40, 0x87, 0xf7, 0x61, 0x4b,
    0x1b, 0x09, 0x26, 0x58, 0x36, 0xaf, 0x33, 0x59, 0x1d, 0x54, 0xc5, 0xd9, 0x99, 0x5e, 0x78, 0x01, 0x01, 0xe3, 0x03,
    0x30, 0x82, 0x03, 0xdf, 0x30, 0x82, 0x02, 0xc7, 0xa0, 0x03, 0x02, 0x01, 0x02, 0x02, 0x01, 0x02, 0x30, 0x0d, 0x06,
    0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x0b, 0x05, 0x00, 0x30, 0x81, 0x92, 0x31, 0x0b, 0x30, 0x09,
    0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x43, 0x4e, 0x31, 0x13, 0x30, 0x11, 0x06, 0x03, 0x55, 0x04, 0x08, 0x0c,
    0x0a, 0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x77, 0x6f, 0x72, 0x6c, 0x64, 0x31, 0x13, 0x30, 0x11, 0x06, 0x03, 0x55, 0x04,
    0x07, 0x0c, 0x0a, 0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x77, 0x6f, 0x72, 0x6c, 0x64, 0x31, 0x13, 0x30, 0x11, 0x06, 0x03,
    0x55, 0x04, 0x0a, 0x0c, 0x0a, 0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x77, 0x6f, 0x72, 0x6c, 0x64, 0x31, 0x13, 0x30, 0x11,
    0x06, 0x03, 0x55, 0x04, 0x0b, 0x0c, 0x0a, 0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x77, 0x6f, 0x72, 0x6c, 0x64, 0x31, 0x14,
    0x30, 0x12, 0x06, 0x03, 0x55, 0x04, 0x03, 0x0c, 0x0b, 0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x77, 0x6f, 0x72, 0x6c, 0x64,
    0x31, 0x31, 0x19, 0x30, 0x17, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x09, 0x01, 0x16, 0x0a, 0x68,
    0x65, 0x6c, 0x6c, 0x6f, 0x77, 0x6f, 0x72, 0x6c, 0x64, 0x30, 0x1e, 0x17, 0x0d, 0x32, 0x32, 0x30, 0x31, 0x32, 0x32,
    0x30, 0x39, 0x32, 0x33, 0x34, 0x38, 0x5a, 0x17, 0x0d, 0x33, 0x32, 0x30, 0x31, 0x32, 0x30, 0x30, 0x39, 0x32, 0x33,
    0x34, 0x38, 0x5a, 0x30, 0x7e, 0x31, 0x0b, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x43, 0x4e, 0x31,
    0x13, 0x30, 0x11, 0x06, 0x03, 0x55, 0x04, 0x08, 0x0c, 0x0a, 0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x77, 0x6f, 0x72, 0x6c,
    0x64, 0x31, 0x13, 0x30, 0x11, 0x06, 0x03, 0x55, 0x04, 0x0a, 0x0c, 0x0a, 0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x77, 0x6f,
    0x72, 0x6c, 0x64, 0x31, 0x13, 0x30, 0x11, 0x06, 0x03, 0x55, 0x04, 0x0b, 0x0c, 0x0a, 0x68, 0x65, 0x6c, 0x6c, 0x6f,
    0x77, 0x6f, 0x72, 0x6c, 0x64, 0x31, 0x15, 0x30, 0x13, 0x06, 0x03, 0x55, 0x04, 0x03, 0x0c, 0x0c, 0x68, 0x65, 0x6c,
    0x6c, 0x6f, 0x77, 0x6f, 0x72, 0x6c, 0x64, 0x31, 0x31, 0x31, 0x19, 0x30, 0x17, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86,
    0xf7, 0x0d, 0x01, 0x09, 0x01, 0x16, 0x0a, 0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x77, 0x6f, 0x72, 0x6c, 0x64, 0x30, 0x82,
    0x01, 0x22, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x01, 0x05, 0x00, 0x03, 0x82,
    0x01, 0x0f, 0x00, 0x30, 0x82, 0x01, 0x0a, 0x02, 0x82, 0x01, 0x01, 0x00, 0xb4, 0xc9, 0x17, 0xe4, 0x80, 0x87, 0xf7,
    0x1c, 0x99, 0xcc, 0x45, 0xfa, 0x57, 0xb4, 0x9b, 0xc5, 0xb1, 0xec, 0xdf, 0x64, 0x72, 0x53, 0x18, 0xa1, 0x45, 0x46,
    0xc8, 0x93, 0x8f, 0x0e, 0xfd, 0x0b, 0xf6, 0x41, 0x3f, 0xd6, 0x18, 0x3d, 0x1c, 0x46, 0xaf, 0x08, 0x15, 0x9a, 0x97,
    0xd6, 0x4a, 0xeb, 0xda, 0xfe, 0x8b, 0x56, 0x22, 0x1f, 0x5f, 0x18, 0xd0, 0x5e, 0x68, 0x02, 0xea, 0x8f, 0xd2, 0xd7,
    0x9e, 0x74, 0x30, 0x72, 0x3e, 0x28, 0xbc, 0x21, 0xa0, 0xea, 0xb8, 0x92, 0x99, 0xd6, 0x19, 0x4c, 0x8b, 0x5d, 0xef,
    0x3d, 0x8d, 0x5c, 0x81, 0x47, 0x06, 0xef, 0xb7, 0x0a, 0xcc, 0x2e, 0x53, 0x32, 0x59, 0x8d, 0x4c, 0xb7, 0xac, 0xd1,
    0xd7, 0x67, 0xf7, 0xf9, 0x58, 0xe1, 0xa8, 0xe5, 0xe2, 0x48, 0x14, 0xaf, 0x76, 0xc2, 0x11, 0x79, 0x69, 0xe2, 0xe8,
    0x41, 0x40, 0xf6, 0x25, 0x9e, 0xdb, 0xa3, 0x72, 0xd7, 0x23, 0x98, 0x47, 0x4c, 0xb5, 0xc2, 0x50, 0x9a, 0x11, 0xe9,
    0xaf, 0x62, 0x6c, 0xf5, 0xca, 0xb6, 0x91, 0x99, 0xde, 0xcb, 0x9f, 0x5a, 0x7b, 0x99, 0x24, 0x2c, 0x2c, 0xe9, 0x16,
    0xaa, 0x63, 0xed, 0xcb, 0xa7, 0xcf, 0x94, 0x6c, 0xdd, 0x16, 0x6c, 0xd7, 0xe3, 0x63, 0xc3, 0x9a, 0x00, 0x05, 0x2d,
    0x7c, 0xa8, 0x0c, 0xb5, 0x08, 0x40, 0x67, 0x79, 0xc2, 0xce, 0x8b, 0xa9, 0x48, 0x3e, 0xf2, 0x1c, 0x92, 0x78, 0x01,
    0x1d, 0xdb, 0xb0, 0x73, 0x33, 0x8c, 0xe5, 0x80, 0x41, 0x5d, 0xea, 0x8e, 0x78, 0xd9, 0x3b, 0x15, 0x64, 0xe2, 0x21,
    0xfe, 0x4c, 0xb9, 0x79, 0x6a, 0x39, 0x29, 0x59, 0xe7, 0xb5, 0xa9, 0xf1, 0x2a, 0x9f, 0x0f, 0x3c, 0x12, 0xe3, 0xd6,
    0xb0, 0xc0, 0x8f, 0x5d, 0xbc, 0x6a, 0x63, 0x83, 0x21, 0xa1, 0xdd, 0x94, 0x00, 0xe5, 0x35, 0xd7, 0x18, 0x62, 0x2c,
    0x9f, 0x97, 0x02, 0x03, 0x01, 0x00, 0x01, 0xa3, 0x53, 0x30, 0x51, 0x30, 0x1d, 0x06, 0x03, 0x55, 0x1d, 0x0e, 0x04,
    0x16, 0x04, 0x14, 0x4d, 0x60, 0x01, 0x09, 0x97, 0x0c, 0x4f, 0x3a, 0x3e, 0x45, 0x07, 0xb3, 0x38, 0x99, 0x3b, 0x0c,
    0xa6, 0x89, 0x11, 0x2f, 0x30, 0x1f, 0x06, 0x03, 0x55, 0x1d, 0x23, 0x04, 0x18, 0x30, 0x16, 0x80, 0x14, 0x9a, 0x77,
    0x73, 0xe5, 0x45, 0xa4, 0x69, 0x42, 0xfe, 0xbf, 0xd4, 0x88, 0xf0, 0xa8, 0xce, 0x81, 0xf5, 0x51, 0xc8, 0x0c, 0x30,
    0x0f, 0x06, 0x03, 0x55, 0x1d, 0x13, 0x01, 0x01, 0xff, 0x04, 0x05, 0x30, 0x03, 0x01, 0x01, 0xff, 0x30, 0x0d, 0x06,
    0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x0b, 0x05, 0x00, 0x03, 0x82, 0x01, 0x01, 0x00, 0x0a, 0xcb,
    0x6d, 0x66, 0x56, 0x1b, 0x77, 0x07, 0xb8, 0x29, 0xcc, 0x04, 0x6a, 0x36, 0xf0, 0x5d, 0x0a, 0x54, 0xa7, 0x2d, 0xc6,
    0x32, 0xd5, 0x38, 0x2c, 0xc3, 0x84, 0xa9, 0xc7, 0x22, 0xeb, 0x0b, 0x56, 0xa4, 0xe7, 0x67, 0xb0, 0x07, 0x79, 0x45,
    0x39, 0xe8, 0xdc, 0xa8, 0x45, 0xf4, 0x91, 0x48, 0x81, 0x09, 0xd9, 0x33, 0x57, 0x90, 0x73, 0xbc, 0x33, 0x2c, 0x4d,
    0x37, 0x79, 0x4f, 0xe1, 0x16, 0xa9, 0x41, 0xab, 0xce, 0xbc, 0x43, 0x4b, 0x13, 0xdf, 0x6c, 0xdb, 0xaf, 0x48, 0xb2,
    0xe2, 0xcf, 0x0a, 0x9d, 0xe4, 0xeb, 0x39, 0xc9, 0x5f, 0x56, 0x56, 0xec, 0xc2, 0x2b, 0x4a, 0x9e, 0xc1, 0xcf, 0xee,
    0xab, 0x05, 0x3b, 0xa1, 0xd8, 0x7f, 0x3b, 0xe0, 0x7f, 0xc1, 0x72, 0xf3, 0xd7, 0x68, 0x26, 0x41, 0xe1, 0x7d, 0xcd,
    0xa6, 0x37, 0xee, 0xe2, 0xd4, 0x5c, 0x28, 0x4b, 0x52, 0x24, 0xa7, 0x55, 0x98, 0x89, 0x68, 0xb6, 0x35, 0xf5, 0xa8,
    0xce, 0x5e, 0x60, 0x76, 0x39, 0x04, 0x34, 0x91, 0xd0, 0xcb, 0xd1, 0x62, 0xf4, 0xa5, 0x1f, 0xbf, 0xf0, 0x03, 0xd1,
    0x44, 0x18, 0x9f, 0x06, 0x1c, 0x8e, 0xef, 0x68, 0x7c, 0x48, 0x33, 0x17, 0xf8, 0xf8, 0xe3, 0xb3, 0xf8, 0x4e, 0x30,
    0xa8, 0xa2, 0x19, 0x65, 0xf6, 0x1e, 0x54, 0x17, 0x44, 0xa5, 0x9b, 0xdf, 0x54, 0x61, 0xd1, 0x6d, 0x2e, 0x5d, 0x12,
    0x87, 0xea, 0x73, 0x83, 0x6d, 0x86, 0x53, 0x9b, 0x4d, 0x69, 0x70, 0x00, 0x88, 0x45, 0x81, 0x3c, 0xcb, 0xab, 0x2f,
    0x32, 0xd9, 0x8d, 0xa3, 0x0d, 0x67, 0x09, 0x93, 0xdd, 0x7f, 0xcb, 0xdb, 0xbc, 0x17, 0x58, 0xd0, 0x02, 0xea, 0x1e,
    0x98, 0x30, 0x98, 0xe4, 0x16, 0xa5, 0x67, 0xe0, 0x67, 0xd1, 0xe6, 0x50, 0x40, 0x79, 0x57, 0xba, 0x3c, 0x32, 0x65,
    0xfa, 0x08, 0x2b, 0xea, 0x02, 0xb9, 0x4a, 0x01, 0x01, 0x0b, 0x04, 0x30, 0x82, 0x04, 0x07, 0x30, 0x82, 0x02, 0xef,
    0xa0, 0x03, 0x02, 0x01, 0x02, 0x02, 0x14, 0x4a, 0xfc, 0x65, 0x4f, 0x67, 0x13, 0x23, 0x9a, 0xe3, 0xeb, 0xb3, 0x60,
    0xe6, 0x5a, 0x90, 0xef, 0xaa, 0x5e, 0x45, 0x8b, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01,
    0x01, 0x0b, 0x05, 0x00, 0x30, 0x81, 0x92, 0x31, 0x0b, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x43,
    0x4e, 0x31, 0x13, 0x30, 0x11, 0x06, 0x03, 0x55, 0x04, 0x08, 0x0c, 0x0a, 0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x77, 0x6f,
    0x72, 0x6c, 0x64, 0x31, 0x13, 0x30, 0x11, 0x06, 0x03, 0x55, 0x04, 0x07, 0x0c, 0x0a, 0x68, 0x65, 0x6c, 0x6c, 0x6f,
    0x77, 0x6f, 0x72, 0x6c, 0x64, 0x31, 0x13, 0x30, 0x11, 0x06, 0x03, 0x55, 0x04, 0x0a, 0x0c, 0x0a, 0x68, 0x65, 0x6c,
    0x6c, 0x6f, 0x77, 0x6f, 0x72, 0x6c, 0x64, 0x31, 0x13, 0x30, 0x11, 0x06, 0x03, 0x55, 0x04, 0x0b, 0x0c, 0x0a, 0x68,
    0x65, 0x6c, 0x6c, 0x6f, 0x77, 0x6f, 0x72, 0x6c, 0x64, 0x31, 0x14, 0x30, 0x12, 0x06, 0x03, 0x55, 0x04, 0x03, 0x0c,
    0x0b, 0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x77, 0x6f, 0x72, 0x6c, 0x64, 0x31, 0x31, 0x19, 0x30, 0x17, 0x06, 0x09, 0x2a,
    0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x09, 0x01, 0x16, 0x0a, 0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x77, 0x6f, 0x72, 0x6c,
    0x64, 0x30, 0x1e, 0x17, 0x0d, 0x32, 0x32, 0x30, 0x31, 0x32, 0x32, 0x30, 0x39, 0x32, 0x31, 0x34, 0x34, 0x5a, 0x17,
    0x0d, 0x33, 0x32, 0x30, 0x31, 0x32, 0x30, 0x30, 0x39, 0x32, 0x31, 0x34, 0x34, 0x5a, 0x30, 0x81, 0x92, 0x31, 0x0b,
    0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x43, 0x4e, 0x31, 0x13, 0x30, 0x11, 0x06, 0x03, 0x55, 0x04,
    0x08, 0x0c, 0x0a, 0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x77, 0x6f, 0x72, 0x6c, 0x64, 0x31, 0x13, 0x30, 0x11, 0x06, 0x03,
    0x55, 0x04, 0x07, 0x0c, 0x0a, 0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x77, 0x6f, 0x72, 0x6c, 0x64, 0x31, 0x13, 0x30, 0x11,
    0x06, 0x03, 0x55, 0x04, 0x0a, 0x0c, 0x0a, 0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x77, 0x6f, 0x72, 0x6c, 0x64, 0x31, 0x13,
    0x30, 0x11, 0x06, 0x03, 0x55, 0x04, 0x0b, 0x0c, 0x0a, 0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x77, 0x6f, 0x72, 0x6c, 0x64,
    0x31, 0x14, 0x30, 0x12, 0x06, 0x03, 0x55, 0x04, 0x03, 0x0c, 0x0b, 0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x77, 0x6f, 0x72,
    0x6c, 0x64, 0x31, 0x31, 0x19, 0x30, 0x17, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x09, 0x01, 0x16,
    0x0a, 0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x77, 0x6f, 0x72, 0x6c, 0x64, 0x30, 0x82, 0x01, 0x22, 0x30, 0x0d, 0x06, 0x09,
    0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x01, 0x05, 0x00, 0x03, 0x82, 0x01, 0x0f, 0x00, 0x30, 0x82, 0x01,
    0x0a, 0x02, 0x82, 0x01, 0x01, 0x00, 0xe7, 0x7f, 0xdc, 0x2f, 0xfb, 0x9c, 0xa3, 0x15, 0x38, 0xd1, 0xe2, 0x21, 0x05,
    0xc7, 0xbf, 0x76, 0x44, 0xec, 0x40, 0x27, 0x74, 0xc2, 0x6c, 0x02, 0xef, 0xeb, 0xc9, 0x7e, 0xc4, 0x01, 0x1b, 0x60,
    0xb6, 0x3c, 0x51, 0xe9, 0xf7, 0x67, 0x1f, 0x62, 0xe7, 0x98, 0xb0, 0x9b, 0xab, 0x89, 0xac, 0x42, 0xb7, 0xaa, 0x15,
    0x72, 0x7f, 0x78, 0xc3, 0x3c, 0x16, 0x40, 0xd9, 0x70, 0xbc, 0xb5, 0xad, 0x53, 0x0c, 0x6d, 0x35, 0x8b, 0xc0, 0x6c,
    0x57, 0x09, 0x79, 0x97, 0xb1, 0x19, 0x5e, 0xfb, 0x6d, 0xd2, 0xdd, 0x0c, 0x70, 0xfe, 0xc0, 0xc0, 0x76, 0x10, 0x46,
    0xbd, 0xab, 0xfa, 0x84, 0x87, 0xcf, 0x2a, 0x31, 0xf4, 0x89, 0xfe, 0xdf, 0xdb, 0xa8, 0xd1, 0x96, 0xd4, 0x59, 0x53,
    0xbc, 0x32, 0x87, 0xb0, 0xb9, 0xb2, 0xc3, 0xd1, 0x3c, 0x98, 0xbe, 0x66, 0xa4, 0xa2, 0x5d, 0x3f, 0x9a, 0x43, 0x96,
    0x6a, 0x7d, 0xcb, 0x53, 0xd0, 0x58, 0xae, 0x36, 0xb2, 0x40, 0x79, 0xb0, 0x7c, 0x8a, 0xfd, 0x27, 0x86, 0x86, 0x75,
    0xf4, 0xeb, 0x82, 0xe5, 0x4a, 0xad, 0x37, 0x2c, 0xff, 0xe7, 0x95, 0x27, 0x27, 0x0e, 0x98, 0x2d, 0xef, 0xe6, 0x44,
    0x20, 0xe2, 0xd6, 0x84, 0xd1, 0x4c, 0x49, 0xc3, 0xeb, 0x08, 0x4b, 0x23, 0x1c, 0x55, 0xc5, 0xe0, 0x15, 0x6f, 0x2a,
    0x95, 0xc0, 0xad, 0x60, 0x8a, 0xb0, 0x32, 0xfc, 0xa2, 0xfd, 0x91, 0x1f, 0x13, 0xf0, 0xef, 0x1c, 0x7b, 0x6c, 0x46,
    0x41, 0x8a, 0x11, 0x89, 0x24, 0xe0, 0xb0, 0x21, 0x86, 0xab, 0x4a, 0xa9, 0x86, 0x49, 0x2b, 0xe8, 0x41, 0xd6, 0x00,
    0x04, 0x67, 0xfe, 0x8e, 0xc7, 0xca, 0xf2, 0xa1, 0x5f, 0x50, 0xec, 0x7d, 0x8b, 0x76, 0x4c, 0x01, 0x0a, 0xbc, 0xe1,
    0x2c, 0x56, 0x3c, 0x65, 0x49, 0x4a, 0xc9, 0xd7, 0x57, 0xaa, 0x93, 0x72, 0x02, 0x79, 0xc7, 0x02, 0x03, 0x01, 0x00,
    0x01, 0xa3, 0x53, 0x30, 0x51, 0x30, 0x1d, 0x06, 0x03, 0x55, 0x1d, 0x0e, 0x04, 0x16, 0x04, 0x14, 0x9a, 0x77, 0x73,
    0xe5, 0x45, 0xa4, 0x69, 0x42, 0xfe, 0xbf, 0xd4, 0x88, 0xf0, 0xa8, 0xce, 0x81, 0xf5, 0x51, 0xc8, 0x0c, 0x30, 0x1f,
    0x06, 0x03, 0x55, 0x1d, 0x23, 0x04, 0x18, 0x30, 0x16, 0x80, 0x14, 0x9a, 0x77, 0x73, 0xe5, 0x45, 0xa4, 0x69, 0x42,
    0xfe, 0xbf, 0xd4, 0x88, 0xf0, 0xa8, 0xce, 0x81, 0xf5, 0x51, 0xc8, 0x0c, 0x30, 0x0f, 0x06, 0x03, 0x55, 0x1d, 0x13,
    0x01, 0x01, 0xff, 0x04, 0x05, 0x30, 0x03, 0x01, 0x01, 0xff, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7,
    0x0d, 0x01, 0x01, 0x0b, 0x05, 0x00, 0x03, 0x82, 0x01, 0x01, 0x00, 0x34, 0x1b, 0xea, 0x9d, 0xe7, 0x6f, 0xe5, 0x89,
    0xce, 0x97, 0xae, 0x5a, 0x5a, 0x66, 0xf0, 0x1f, 0xd6, 0x32, 0x3b, 0xe5, 0xf6, 0x40, 0x45, 0xd0, 0x04, 0xd1, 0x13,
    0x3d, 0x49, 0x7d, 0x68, 0xb9, 0x81, 0x7f, 0x02, 0x33, 0x6e, 0xf1, 0xab, 0x6b, 0x49, 0x03, 0xb2, 0x5f, 0x8c, 0x73,
    0xd0, 0x3c, 0xfc, 0xd8, 0x27, 0xc2, 0x8a, 0x5f, 0xe9, 0x6b, 0x31, 0x22, 0xc9, 0xa8, 0x02, 0x85, 0x27, 0xb6, 0xe3,
    0xd4, 0x91, 0x5f, 0x15, 0x17, 0x50, 0x3e, 0xaf, 0xdb, 0x25, 0x6e, 0x5e, 0x38, 0xc6, 0x25, 0xd6, 0x63, 0x3f, 0x74,
    0xb8, 0x4f, 0xa8, 0x8c, 0xab, 0x7e, 0x19, 0x83, 0x89, 0x4d, 0xc5, 0xa3, 0xc3, 0xfd, 0xd5, 0xb9, 0x84, 0x76, 0xc8,
    0x29, 0x7f, 0xcd, 0x17, 0x0c, 0xcc, 0xce, 0x9e, 0x60, 0xb9, 0xcf, 0xad, 0x81, 0x32, 0xd5, 0x65, 0x12, 0x0b, 0x2e,
    0xf4, 0x36, 0x56, 0x03, 0xbd, 0x13, 0xd6, 0x42, 0xdd, 0xfb, 0xc9, 0xe5, 0xd0, 0x4a, 0x9c, 0xe1, 0xf2, 0x45, 0x1f,
    0x23, 0x13, 0x56, 0xfb, 0xc1, 0x9e, 0x41, 0x9b, 0xad, 0xf9, 0x16, 0xaa, 0x0c, 0x23, 0x81, 0x9d, 0x27, 0xd7, 0x68,
    0xa9, 0x49, 0x1e, 0xb5, 0xb5, 0xa6, 0xbb, 0x11, 0x5a, 0x37, 0x13, 0x4e, 0x97, 0xbd, 0x28, 0x17, 0x83, 0x6a, 0x6a,
    0x2f, 0x2e, 0xa2, 0x00, 0x42, 0xc7, 0xfe, 0x0f, 0xfc, 0xaf, 0x88, 0x84, 0x65, 0xa2, 0x4f, 0x02, 0x13, 0xfd, 0xa9,
    0x4b, 0xb6, 0x31, 0xc5, 0xfa, 0x41, 0xd3, 0x4b, 0xa6, 0xb0, 0xe3, 0x0c, 0x4a, 0xaf, 0xaa, 0x0b, 0x8f, 0xc5, 0x34,
    0x9c, 0x77, 0xc1, 0x35, 0x65, 0x03, 0x2d, 0x2b, 0x0c, 0x4b, 0xdd, 0x69, 0xc6, 0xe4, 0x97, 0xf8, 0x2d, 0x49, 0x3a,
    0xdd, 0x26, 0xb7, 0x09, 0xd3, 0x3d, 0xee, 0xc5, 0x09, 0x21, 0xcd, 0x73, 0x41, 0x05, 0xc1, 0xf1, 0xdb, 0x8e, 0x3a,
    0x7f};

void DslmTest::SetUpTestCase()
{
    // modify the device's systime to ensure that the certificate verification passes
    constexpr time_t yearTimeLeast = 1699977600;
    constexpr time_t yearTimeValid = 1704038400;
    struct timeval timeVal = {0};
    string isEnforcing;

    gettimeofday(&timeVal, nullptr);
    if (timeVal.tv_sec <= yearTimeLeast) {
        timeVal.tv_sec = yearTimeValid;
        settimeofday(&timeVal, nullptr);
    }

    static const char *acls[] = {"ACCESS_IDS"};
    static const char *perms[] = {
        "ohos.permission.PLACE_CALL",
        "ohos.permission.ACCESS_IDS",
    };
    uint64_t tokenId;
    NativeTokenInfoParams infoInstance = {
        .dcapsNum = 0,
        .permsNum = 2,
        .aclsNum = 1,
        .dcaps = nullptr,
        .perms = perms,
        .acls = acls,
        .processName = "dslm_service",
        .aplStr = "system_core",
    };
    tokenId = GetAccessTokenId(&infoInstance);
    SetSelfTokenID(tokenId);
    LoadStringFromFile("/sys/fs/selinux/enforce", isEnforcing);
    if (isEnforcing.compare("1") == 0) {
        DslmTest::isEnforcing_ = true;
        SaveStringToFile("/sys/fs/selinux/enforce", "0");
    }
}
void DslmTest::TearDownTestCase()
{
    if (DslmTest::isEnforcing_) {
        SaveStringToFile("/sys/fs/selinux/enforce", "1");
    }
}
void DslmTest::SetUp()
{
}
void DslmTest::TearDown()
{
}
bool DslmTest::isEnforcing_ = false;

static void BlockCheckDeviceStatus(const DeviceIdentify *device, uint32_t status, uint64_t millisec)
{
    static int sleepTick = 10;
    uint64_t cnt = millisec / static_cast<uint64_t>(sleepTick) + 1;
    do {
        const DslmDeviceInfo *info = GetDslmDeviceInfo(device);
        if (info == nullptr) {
            continue;
        }
        if (info->machine.currState == status) {
            break;
        }
        if (cnt == 0) {
            break;
        }
        this_thread::sleep_for(milliseconds(sleepTick));
        cnt--;
    } while (true);
}

HWTEST_F(DslmTest, BuildDeviceSecInfoRequest_case1, TestSize.Level0)
{
    uint64_t random = 0x0807060504030201;
    MessageBuff *msg = nullptr;
    // 0d196608 = 0x030000
    const char *except = "{\"message\":1,\"payload\":{\"version\":196608,\"challenge\":\"0102030405060708\","
                         "\"support\":[3000,2000,1000]}}";
    int32_t ret = BuildDeviceSecInfoRequest(random, &msg);
    ASSERT_EQ(0, ret);
    EXPECT_STREQ(except, (const char *)msg->buff);
    FreeMessageBuff(msg);
}

HWTEST_F(DslmTest, BuildDeviceSecInfoRequest_case2, TestSize.Level0)
{
    uint64_t random = 0x0807060504030201;
    MessageBuff **msg = nullptr;
    int32_t ret = BuildDeviceSecInfoRequest(random, msg);
    ASSERT_EQ(ERR_INVALID_PARA, ret);
}

HWTEST_F(DslmTest, BuildDeviceSecInfoRequest_case3, TestSize.Level0)
{
    uint64_t random = 0x0807060504030201;
    const char *message = "{\"mege\":1,\"payload\":{\"version\":131072,\"challenge\":\"0102030405060708\"}}";
    uint32_t messageLen = strlen(message) + 1;
    MessageBuff msg = {.length = messageLen, .buff = (uint8_t *)message};
    MessageBuff *msg_ptr = &msg;

    int32_t ret = BuildDeviceSecInfoRequest(random, &msg_ptr);
    ASSERT_EQ(ERR_INVALID_PARA, ret);
}

HWTEST_F(DslmTest, BuildDeviceSecInfoResponse_case1, TestSize.Level0)
{
    uint64_t random = 0x0807060504030201;
    uint8_t info[] = {'a', 'b', 'c', 'd', 1, 3, 5, 7, 9};
    DslmCredBuff cred = {(CredType)3, 9, info};

    // 0d196608 = 0x030000
    const char *except = "{\"message\":2,\"payload\":{\"version\":196608,\"type\":3,\"challenge\":\"0102030405060708\","
                         "\"info\":\"YWJjZAEDBQcJ\"}}";

    MessageBuff *msg = nullptr;
    int32_t ret = BuildDeviceSecInfoResponse(random, (DslmCredBuff *)&cred, &msg);
    ASSERT_EQ(0, ret);

    EXPECT_STREQ(except, (const char *)msg->buff);
    FreeMessageBuff(msg);
}

HWTEST_F(DslmTest, BuildDeviceSecInfoResponse_case2, TestSize.Level0)
{
    uint64_t random = 0x0807060504030201;
    uint8_t info[] = {'a', 'b', 'c', 'd', 1, 3, 5, 7, 9};
    DslmCredBuff cred = {(CredType)3, 9, info};

    {
        MessageBuff **msg = nullptr;

        int32_t ret = BuildDeviceSecInfoResponse(random, (DslmCredBuff *)&cred, msg);
        ASSERT_EQ(ERR_INVALID_PARA, ret);

        ret = BuildDeviceSecInfoResponse(random, nullptr, msg);
    }

    {
        MessageBuff msg;
        memset_s(&msg, sizeof(MessageBuff), 0, sizeof(MessageBuff));
        MessageBuff *msgPtr = &msg;

        int32_t ret = BuildDeviceSecInfoResponse(random, (DslmCredBuff *)&cred, &msgPtr);
        ASSERT_EQ(ERR_INVALID_PARA, ret);
    }
}

HWTEST_F(DslmTest, ParseMessage_case1, TestSize.Level0)
{
    const char *message = "{\"message\":1,\"payload\":{\"version\":131072,\"challenge\":\"0102030405060708\"}}";
    const char *except = "{\"version\":131072,\"challenge\":\"0102030405060708\"}";

    uint32_t messageLen = strlen(message) + 1;
    MessageBuff msg = {.length = messageLen, .buff = (uint8_t *)message};

    MessagePacket *packet = ParseMessage(&msg);
    ASSERT_NE(nullptr, packet);

    EXPECT_EQ(1U, packet->type);
    EXPECT_STREQ(except, (const char *)packet->payload);

    FreeMessagePacket(packet);
}

HWTEST_F(DslmTest, ParseMessage_case2, TestSize.Level0)
{
    const char *message = "{\"mege\":1,\"payload\":{\"version\":131072,\"challenge\":\"0102030405060708\"}}";

    uint32_t messageLen = strlen(message) + 1;
    MessageBuff msg = {.length = messageLen, .buff = (uint8_t *)message};

    MessagePacket *packet = ParseMessage(&msg);
    EXPECT_EQ(nullptr, packet);
    FreeMessagePacket(packet);
}

HWTEST_F(DslmTest, ParseMessage_case3, TestSize.Level0)
{
    const char *message = "{\"message\":1,\"pay\":{\"version\":131072,\"challenge\":\"0102030405060708\"}}";

    uint32_t messageLen = strlen(message) + 1;
    MessageBuff msg = {.length = messageLen, .buff = (uint8_t *)message};

    MessagePacket *packet = ParseMessage(&msg);
    EXPECT_EQ(nullptr, packet);
    FreeMessagePacket(packet);
}

HWTEST_F(DslmTest, ParseMessage_case4, TestSize.Level0)
{
    const MessageBuff *buff = nullptr;
    EXPECT_EQ(nullptr, ParseMessage(buff));
}

HWTEST_F(DslmTest, ParseMessage_case5, TestSize.Level0)
{
    uint8_t *message = nullptr;
    uint32_t messageLen = 0;
    MessageBuff msg = {.length = messageLen, .buff = message};

    EXPECT_EQ(nullptr, ParseMessage(&msg));
}

HWTEST_F(DslmTest, ParseMessage_case6, TestSize.Level0)
{
    uint8_t message[] = {'1', '2'};
    uint32_t messageLen = 2;
    MessageBuff msg = {.length = messageLen, .buff = message};
    EXPECT_EQ(nullptr, ParseMessage(&msg));
}

HWTEST_F(DslmTest, ParseMessage_case7, TestSize.Level0)
{
    uint8_t message[] = {1, 2, 0};
    uint32_t messageLen = 3;
    MessageBuff msg = {.length = messageLen, .buff = message};
    EXPECT_EQ(nullptr, ParseMessage(&msg));
}

HWTEST_F(DslmTest, ParseMessage_case8, TestSize.Level0)
{
    MockMalloc mock;

    // mock the malloc return nullptr
    EXPECT_CALL(mock, UtilsMalloc).WillRepeatedly(Return(nullptr));

    const char *message = "{\"message\":1,\"payload\":{\"version\":131072,\"challenge\":\"0102030405060708\"}}";

    uint32_t messageLen = strlen(message) + 1;
    MessageBuff msg = {.length = messageLen, .buff = (uint8_t *)message};

    MessagePacket *packet = ParseMessage(&msg);
    ASSERT_EQ(nullptr, packet);
}

HWTEST_F(DslmTest, GetPkInfoListStr_case1, TestSize.Level0)
{
    const char *udidStr = "device";
    char *pkInfoListStr = nullptr;

    int32_t result = GetPkInfoListStr(true, udidStr, &pkInfoListStr);
    EXPECT_EQ(result, 0);
}

HWTEST_F(DslmTest, GetPkInfoListStr_case2, TestSize.Level0)
{
    const char *udidStr = "device";
    char *pkInfoListStr = nullptr;

    MockMalloc mock;

    // mock the malloc always return nullptr
    EXPECT_CALL(mock, UtilsMalloc).WillOnce(Return(nullptr));

    int32_t result = GetPkInfoListStr(true, udidStr, &pkInfoListStr);
    EXPECT_EQ(result, ERR_MEMORY_ERR);
}

HWTEST_F(DslmTest, GetPkInfoListStr_case3, TestSize.Level0)
{
    const char *udidStr = "device";
    char *pkInfoListStr = nullptr;

    MockStrcpy mock;
    // mock the strcpy_s return a EINVAL
    EXPECT_CALL(mock, strcpy_s).WillOnce(Return(EINVAL));

    int32_t result = GetPkInfoListStr(true, udidStr, &pkInfoListStr);
    EXPECT_EQ(result, ERR_MEMORY_ERR);
}

HWTEST_F(DslmTest, ParseDeviceSecInfoRequest_case1, TestSize.Level0)
{
    const char *message = "{\"version\":3351057,\"challenge\":\"010203040a0b0c0d\"}";

    uint32_t messageLen = strlen(message) + 1;
    MessageBuff msg = {.length = messageLen, .buff = (uint8_t *)message};

    RequestObject obj;
    (void)memset_s(&obj, sizeof(RequestObject), 0, sizeof(RequestObject));

    // 3351057 = 0x332211
    int32_t ret = ParseDeviceSecInfoRequest(&msg, &obj);
    EXPECT_EQ(0, ret);

    EXPECT_EQ(0x332211U, obj.version);
    EXPECT_EQ(0x0d0c0b0a04030201UL, obj.challenge);
    EXPECT_EQ(0U, obj.arraySize);
}

HWTEST_F(DslmTest, ParseDeviceSecInfoRequest_case2, TestSize.Level0)
{
    const char *message = "{\"version\":3351057,\"challenge\":\"z\"}";

    uint32_t messageLen = strlen(message) + 1;
    MessageBuff msg = {.length = messageLen, .buff = (uint8_t *)message};

    RequestObject obj;
    (void)memset_s(&obj, sizeof(RequestObject), 0, sizeof(RequestObject));

    int32_t ret = ParseDeviceSecInfoRequest(&msg, &obj);
    EXPECT_EQ(ERR_NO_CHALLENGE, ret);
}

HWTEST_F(DslmTest, ParseDeviceSecInfoRequest_case3, TestSize.Level0)
{
    const char *message = "{\"version\":3351057,\"challenge\":1}";

    uint32_t messageLen = strlen(message) + 1;
    MessageBuff msg = {.length = messageLen, .buff = (uint8_t *)message};

    RequestObject obj;
    (void)memset_s(&obj, sizeof(RequestObject), 0, sizeof(RequestObject));
    int32_t ret = ParseDeviceSecInfoRequest(&msg, &obj);
    EXPECT_EQ(ERR_NO_CHALLENGE, ret);
}

HWTEST_F(DslmTest, ParseDeviceSecInfoRequest_case4, TestSize.Level0)
{
    const char *message = "{\"version\":3351057,\"challssenge\":\"z\"}";

    uint32_t messageLen = strlen(message) + 1;
    MessageBuff msg = {.length = messageLen, .buff = (uint8_t *)message};

    RequestObject obj;
    (void)memset_s(&obj, sizeof(RequestObject), 0, sizeof(RequestObject));
    int32_t ret = ParseDeviceSecInfoRequest(&msg, &obj);
    EXPECT_EQ(ERR_NO_CHALLENGE, ret);
}

HWTEST_F(DslmTest, ParseDeviceSecInfoRequest_case5, TestSize.Level0)
{
    const char *message = "{\"version\":3351057,\"challenge\":\"010203040a0b0c0d\",\"support\":[33,44,55]}";

    uint32_t messageLen = strlen(message) + 1;
    MessageBuff msg = {.length = messageLen, .buff = (uint8_t *)message};

    RequestObject obj;
    (void)memset_s(&obj, sizeof(RequestObject), 0, sizeof(RequestObject));

    // 3351057 = 0x332211
    int32_t ret = ParseDeviceSecInfoRequest(&msg, &obj);
    EXPECT_EQ(static_cast<int32_t>(0), ret);
    EXPECT_EQ(0x332211U, obj.version);
    EXPECT_EQ(0x0d0c0b0a04030201U, obj.challenge);
    // add support
    EXPECT_EQ(3U, obj.arraySize);
    EXPECT_EQ(33U, obj.credArray[0]);
    EXPECT_EQ(44U, obj.credArray[1]);
    EXPECT_EQ(55U, obj.credArray[2]);
}

HWTEST_F(DslmTest, ParseDeviceSecInfoRequest_case6, TestSize.Level0)
{
    const char *message = "{\"version\":3351057,\"challenge\":\"010203040a0b0c0d\",\"support\":[]}";

    uint32_t messageLen = strlen(message) + 1;
    MessageBuff msg = {.length = messageLen, .buff = (uint8_t *)message};

    RequestObject obj;
    (void)memset_s(&obj, sizeof(RequestObject), 0, sizeof(RequestObject));

    // 3351057 = 0x332211
    int32_t ret = ParseDeviceSecInfoRequest(&msg, &obj);
    EXPECT_EQ(0, ret);
    EXPECT_EQ(0x332211U, obj.version);
    EXPECT_EQ(0x0d0c0b0a04030201U, obj.challenge);
    // add support
    EXPECT_EQ(0U, obj.arraySize);
}

HWTEST_F(DslmTest, ParseDeviceSecInfoRequest_case7, TestSize.Level0)
{
    const char *message = "{\"version\":3351057,\"challenge\":\"010203040a0b0c0d\",\"support\":[]}";
    uint32_t messageLen = strlen(message) + 1;
    MessageBuff msg = {.length = messageLen, .buff = (uint8_t *)message};

    RequestObject obj;
    (void)memset_s(&obj, sizeof(RequestObject), 0, sizeof(RequestObject));

    {
        int32_t ret = ParseDeviceSecInfoRequest(nullptr, &obj);
        EXPECT_EQ(ERR_INVALID_PARA, ret);
    }

    {
        int32_t ret = ParseDeviceSecInfoRequest(&msg, nullptr);
        EXPECT_EQ(ERR_INVALID_PARA, ret);
    }

    {
        int32_t ret = ParseDeviceSecInfoRequest(nullptr, &obj);
        EXPECT_EQ(ERR_INVALID_PARA, ret);
    }

    {
        msg.buff = nullptr;
        int32_t ret = ParseDeviceSecInfoRequest(&msg, &obj);
        EXPECT_EQ(ERR_INVALID_PARA, ret);
    }
}

HWTEST_F(DslmTest, ParseDeviceSecInfoRequest_case8, TestSize.Level0)
{
    const char *message = "{\"version\":3351057,\"challenge}";

    uint32_t messageLen = strlen(message) + 1;
    MessageBuff msg = {.length = messageLen, .buff = (uint8_t *)message};

    RequestObject obj;
    (void)memset_s(&obj, sizeof(RequestObject), 0, sizeof(RequestObject));

    // 3351057 = 0x332211
    int32_t ret = ParseDeviceSecInfoRequest(&msg, &obj);
    EXPECT_EQ(ERR_INVALID_PARA, ret);
}

HWTEST_F(DslmTest, ParseDeviceSecInfoResponse_case1, TestSize.Level0)
{
    const char *message = "{\"version\":131072,\"challenge\":\"3C1F21EE53D3C4E2\",\"type\":2,\"info\":"
                          "\"SkFERS1BTDAwOjg3QUQyOEQzQjFCLi4u\"}";

    uint32_t messageLen = strlen(message) + 1;
    MessageBuff msg = {.length = messageLen, .buff = (uint8_t *)message};

    uint64_t challenge;
    uint32_t version;
    DslmCredBuff *cred = nullptr;

    // 131072 = 0x020000
    int32_t ret = ParseDeviceSecInfoResponse(&msg, &challenge, &version, &cred);
    EXPECT_EQ(0, ret);
    EXPECT_EQ(0x020000U, version);

    EXPECT_EQ(0xE2C4D353EE211F3CUL, challenge);

    const char *except = "JADE-AL00:87AD28D3B1B...";
    EXPECT_NE(nullptr, cred);
    EXPECT_EQ(2U, cred->type);
    EXPECT_EQ(strlen(except), cred->credLen);
    EXPECT_EQ(0, strncmp(except, (const char *)cred->credVal, cred->credLen));
    DestroyDslmCred(cred);
}

HWTEST_F(DslmTest, ParseDeviceSecInfoResponse_case2, TestSize.Level0)
{
    const char *message = "{\"version\":3351057,\"challssenge\":\"z\"}";

    uint32_t messageLen = strlen(message) + 1;
    MessageBuff msg = {.length = messageLen, .buff = (uint8_t *)message};

    uint64_t challenge;
    uint32_t ver;
    DslmCredBuff *cred = nullptr;

    int32_t ret = ParseDeviceSecInfoResponse(&msg, &challenge, &ver, &cred);
    EXPECT_EQ(ERR_NO_CHALLENGE, ret);
}

HWTEST_F(DslmTest, ParseDeviceSecInfoResponse_case3, TestSize.Level0)
{
    const char *message =
        "{\"version\":131072,\"challenge\":\"3C1F21EE53D3C4E2\",\"type\":2,\"infod\":\"JADE-AL00:87AD28D3B1B...\"}";

    uint32_t messageLen = strlen(message) + 1;
    MessageBuff msg = {.length = messageLen, .buff = (uint8_t *)message};

    uint64_t challenge;
    uint32_t ver;
    DslmCredBuff *cred = nullptr;

    int32_t ret = ParseDeviceSecInfoResponse(&msg, &challenge, &ver, &cred);
    EXPECT_EQ(ERR_NO_CRED, ret);
}

HWTEST_F(DslmTest, ParseDeviceSecInfoResponse_case4, TestSize.Level0)
{
    const char *message =
        "{\"version\":131072,\"challenge\":\"3C1F21EE53D3C4E2\",\"type\":2,\"infod\":\"JADE-AL00:87AD28D3B1B...\"}";

    uint32_t messageLen = strlen(message) + 1;
    MessageBuff msg = {.length = messageLen, .buff = (uint8_t *)message};

    uint64_t challenge;
    uint32_t ver;
    DslmCredBuff **cred = nullptr;

    int32_t ret = ParseDeviceSecInfoResponse(&msg, &challenge, &ver, cred);
    EXPECT_EQ(ERR_INVALID_PARA, ret);
}

HWTEST_F(DslmTest, ParseDeviceSecInfoResponse_case5, TestSize.Level0)
{
    const char *message = "{\"version\":131072,\"challenge\":\"3C1F21EE53D3C4E2\",\"type\":2,\"info\":"
                          "\"SkFERS1BTDAwOjg3QUQyOEQzQjFCLi4u\"}";

    uint32_t messageLen = strlen(message) + 1;
    // msg has null buff
    MessageBuff msg = {.length = messageLen, .buff = nullptr};

    uint64_t challenge;
    uint32_t version;
    DslmCredBuff *cred = nullptr;

    // 131072 = 0x020000
    int32_t ret = ParseDeviceSecInfoResponse(&msg, &challenge, &version, &cred);
    EXPECT_EQ(ERR_INVALID_PARA, ret);
}

HWTEST_F(DslmTest, ParseDeviceSecInfoResponse_case6, TestSize.Level0)
{
    int32_t ret;
    const char *message = "{\"version\":131072,\"challenge\":\"3C1F21EE53D3C4E2\",\"type\":2,\"info\":"
                          "\"SkFERS1BTDAwOjg3QUQyOEQzQjFCLi4u\"}";
    uint32_t messageLen = strlen(message) + 1;
    MessageBuff msg = {.length = messageLen, .buff = (uint8_t *)message};

    uint64_t challenge;
    uint32_t ver;
    DslmCredBuff cred;
    memset_s(&cred, sizeof(DslmCredBuff), 0, sizeof(DslmCredBuff));
    DslmCredBuff *credPtr = &cred;

    {
        // malformed inputs
        ret = ParseDeviceSecInfoResponse(&msg, &challenge, &ver, nullptr);
        EXPECT_EQ(ERR_INVALID_PARA, ret);
    }

    {
        // malformed inputs, credPtr != nullptr
        ret = ParseDeviceSecInfoResponse(&msg, &challenge, &ver, &credPtr);
        EXPECT_EQ(ERR_INVALID_PARA, ret);
    }

    {
        ret = ParseDeviceSecInfoResponse(nullptr, &challenge, &ver, &credPtr);
        EXPECT_EQ(ERR_INVALID_PARA, ret);
    }

    {
        ret = ParseDeviceSecInfoResponse(&msg, nullptr, &ver, &credPtr);
        EXPECT_EQ(ERR_INVALID_PARA, ret);
    }

    {
        ret = ParseDeviceSecInfoResponse(&msg, &challenge, nullptr, &credPtr);
        EXPECT_EQ(ERR_INVALID_PARA, ret);
    }
}

HWTEST_F(DslmTest, ParseDeviceSecInfoResponse_case7, TestSize.Level0)
{
    int32_t ret;
    uint64_t challenge;
    uint32_t version;
    DslmCredBuff *cred = nullptr;

    {
        // malformed challenge
        const char *message = "{\"version\":131072,\"challenge\":\"3C1F21EE53D3C4E2A\",\"type\":2,\"info\":"
                              "\"SkFERS1BTDAwOjg3QUQyOEQzQjFCLi4u\"}";
        uint32_t messageLen = strlen(message) + 1;
        MessageBuff msg = {.length = messageLen, .buff = (uint8_t *)message};

        // 131072 = 0x020000
        ret = ParseDeviceSecInfoResponse(&msg, &challenge, &version, &cred);
        EXPECT_EQ(ERR_NO_CHALLENGE, ret);
    }

    {
        // malformed json
        const char *message = "{\"version\":131072,\"challenge\":\"3C1F21EE53D3C4E2\",\"type\":2,\"infod}";
        uint32_t messageLen = strlen(message) + 1;
        MessageBuff msg = {.length = messageLen, .buff = (uint8_t *)message};

        ret = ParseDeviceSecInfoResponse(&msg, &challenge, &version, &cred);
        EXPECT_EQ(ERR_INVALID_PARA, ret);
    }
}

HWTEST_F(DslmTest, ParseDeviceSecInfoResponse_case8, TestSize.Level0)
{
    // malformed info field
    const char *message = "{\"version\":131072,\"challenge\":\"3C1F21EE53D3C4E2\",\"type\":2,\"info\":"
                          "\"SkFERS1BTDAwOjg3QUQyOEQzQjFCLi4ux\"}";

    uint32_t messageLen = strlen(message) + 1;
    MessageBuff msg = {.length = messageLen, .buff = (uint8_t *)message};

    uint64_t challenge;
    uint32_t version;
    DslmCredBuff *cred = nullptr;

    // 131072 = 0x020000
    int32_t ret = ParseDeviceSecInfoResponse(&msg, &challenge, &version, &cred);
    EXPECT_EQ(ERR_NO_CRED, ret);
}

HWTEST_F(DslmTest, RandomValue_case1, TestSize.Level0)
{
    RandomValue rand1 = {0, {0}};
    (void)memset_s(&rand1, sizeof(RandomValue), 0, sizeof(RandomValue));
    GenerateRandom(&rand1, sizeof(uint64_t));

    RandomValue rand2 = {0, {0}};
    (void)memset_s(&rand2, sizeof(RandomValue), 0, sizeof(RandomValue));
    GenerateRandom(&rand2, sizeof(uint64_t));

    EXPECT_EQ(sizeof(uint64_t), rand1.length);
    EXPECT_EQ(sizeof(uint64_t), rand2.length);

    EXPECT_GT(rand1.value[0] + rand1.value[1] + rand1.value[2] + rand1.value[3], 0);
    EXPECT_EQ(rand1.value[31] + rand1.value[30] + rand1.value[29] + rand1.value[28], 0);
    EXPECT_NE(0, memcmp(rand1.value, rand2.value, sizeof(uint64_t)));
}

HWTEST_F(DslmTest, RandomValue_case2, TestSize.Level0)
{
    RandomValue rand = {0, {0}};
    (void)memset_s(&rand, sizeof(RandomValue), 0, sizeof(RandomValue));

    GenerateRandom(&rand, 1024);
    EXPECT_EQ(static_cast<uint32_t>(RANDOM_MAX_LEN), rand.length);

    GenerateRandom(nullptr, 1024);
}

HWTEST_F(DslmTest, GetMillisecondSinceBoot_case1, TestSize.Level0)
{
    uint64_t tick = 100;
    uint64_t start = GetMillisecondSinceBoot();
    EXPECT_GT(start, 0U);
    this_thread::sleep_for(milliseconds(tick));
    uint64_t end = GetMillisecondSinceBoot();
    EXPECT_GT(end, 0U);

    EXPECT_GT(end - start, tick - 25);
    EXPECT_LT(end - start, tick + 25);
}

HWTEST_F(DslmTest, GetMillisecondSince1970_case1, TestSize.Level0)
{
    uint64_t tick = 100;
    uint64_t start = GetMillisecondSince1970();
    EXPECT_GT(start, 0U);
    this_thread::sleep_for(milliseconds(tick));
    uint64_t end = GetMillisecondSince1970();
    EXPECT_GT(end, 0U);

    EXPECT_GT(end - start, tick - 25);
    EXPECT_LT(end - start, tick + 25);
}

HWTEST_F(DslmTest, GetDateTime_case1, TestSize.Level0)
{
    {
        DateTime date;
        EXPECT_TRUE(GetDateTimeByMillisecondSince1970(GetMillisecondSince1970(), &date));
    }
    {
        DateTime date;
        EXPECT_TRUE(GetDateTimeByMillisecondSinceBoot(GetMillisecondSinceBoot(), &date));
    }
}

HWTEST_F(DslmTest, InitDslmCredentialFunctions_case1, TestSize.Level0)
{
    bool ret = InitDslmCredentialFunctions(NULL);
    EXPECT_EQ(false, ret);
}

HWTEST_F(DslmTest, OhosDslmCred_case1, TestSize.Level0)
{
    const DeviceIdentify identify = {DEVICE_ID_MAX_LEN, {0}};
    RequestObject object;

    object.arraySize = 1;
    object.credArray[0] = CRED_TYPE_STANDARD;
    object.challenge = 0x1234567812345678;
    object.version = 0x112234;

    DslmCredBuff *cred = nullptr;

    int32_t ret = DefaultRequestDslmCred(&identify, &object, &cred);

    DslmCredInfo info;
    (void)memset_s(&info, sizeof(DslmCredInfo), 0, sizeof(DslmCredInfo));

    ret = DefaultVerifyDslmCred(&identify, object.challenge, cred, &info);

    DestroyDslmCred(cred);
}

HWTEST_F(DslmTest, OhosDslmCred_case2, TestSize.Level0)
{
    const DeviceIdentify identify = {DEVICE_ID_MAX_LEN, {0}};
    RequestObject object;

    object.arraySize = 1;
    object.credArray[0] = CRED_TYPE_STANDARD;
    object.challenge = 0x1234567812345678;
    object.version = 0x112234;

    DslmCredBuff cred = {
        .type = (CredType)3000,
        .credLen = sizeof(CRED),
        .credVal = &CRED[0],
    };

    DslmCredInfo info;
    (void)memset_s(&info, sizeof(DslmCredInfo), 0, sizeof(DslmCredInfo));

    int32_t ret = DefaultVerifyDslmCred(&identify, object.challenge, &cred, &info);
    EXPECT_EQ(SUCCESS, ret);
    EXPECT_GE(info.credLevel, 1U);
}

HWTEST_F(DslmTest, OnRequestDeviceSecLevelInfo_case1, TestSize.Level0)
{
    const DeviceIdentify device = {DEVICE_ID_MAX_LEN, {'a', 'b', 'c', 'd', 'e', 'f', 'g'}};

    const RequestOption option = {
        .challenge = 0xffffffffffffffff,
        .timeout = 2,
    };

    {
        uint32_t cookie = 1234;
        DslmRequestCallbackMock mockCallback;
        EXPECT_CALL(mockCallback, RequestCallback(_, _, _)).Times(Exactly(0));
        int32_t ret = OnRequestDeviceSecLevelInfo(&device, &option, 0, cookie, DslmRequestCallbackMock::MockedCallback);
        EXPECT_EQ(static_cast<int32_t>(ret), ERR_MSG_NOT_INIT);
    }

    {
        uint32_t cookie = 1234;
        DslmRequestCallbackMock mockCallback;
        EXPECT_CALL(mockCallback, RequestCallback(_, _, _)).Times(Exactly(0));
        int32_t ret = OnRequestDeviceSecLevelInfo(nullptr, &option, 0, cookie, DslmRequestCallbackMock::MockedCallback);
        EXPECT_EQ(static_cast<int32_t>(ret), ERR_INVALID_PARA);
    }

    {
        uint32_t cookie = 1234;
        DslmRequestCallbackMock mockCallback;
        EXPECT_CALL(mockCallback, RequestCallback(_, _, _)).Times(Exactly(0));
        int32_t ret = OnRequestDeviceSecLevelInfo(&device, nullptr, 0, cookie, DslmRequestCallbackMock::MockedCallback);
        EXPECT_EQ(static_cast<int32_t>(ret), ERR_INVALID_PARA);
    }

    {
        uint32_t cookie = 5678;
        DslmMsgInterfaceMock mockMsg;
        DslmRequestCallbackMock mockCallback;
        EXPECT_CALL(mockMsg, IsMessengerReady(_)).Times(AtLeast(1));
        EXPECT_CALL(mockMsg, GetSelfDeviceIdentify(_, _, _)).Times(AtLeast(1));
        EXPECT_CALL(mockMsg, GetDeviceOnlineStatus(_, _, _)).Times(AtLeast(1)).WillRepeatedly(Return(false));
        EXPECT_CALL(mockCallback, RequestCallback(_, _, _)).Times(Exactly(0));
        int32_t ret = OnRequestDeviceSecLevelInfo(&device, &option, 0, cookie, DslmRequestCallbackMock::MockedCallback);
        EXPECT_EQ(static_cast<int32_t>(ret), ERR_NOEXIST_DEVICE);

        EXPECT_CALL(mockMsg, SendMsgTo(_, _, _, _, _)).Times(AtLeast(2));
        mockMsg.MakeMsgLoopback();
        mockMsg.MakeDeviceOnline(&device);
        BlockCheckDeviceStatus(&device, STATE_SUCCESS, 10000);
        mockMsg.MakeDeviceOffline(&device);
    }
}

HWTEST_F(DslmTest, OnRequestDeviceSecLevelInfo_case2, TestSize.Level0)
{
    const DeviceIdentify device = {DEVICE_ID_MAX_LEN, {'a', 'b', 'c', 'd', 'e', 'f', 'g'}};

    const RequestOption option = {
        .challenge = 0xffffffffffffffff,
        .timeout = 2,
    };

    {
        uint32_t cookie = 0xabcd;
        DslmMsgInterfaceMock mockMsg;
        EXPECT_CALL(mockMsg, IsMessengerReady(_)).Times(AtLeast(1));
        EXPECT_CALL(mockMsg, GetSelfDeviceIdentify(_, _, _)).Times(AtLeast(1));
        EXPECT_CALL(mockMsg, GetDeviceOnlineStatus(_, _, _)).Times(AtLeast(1)).WillRepeatedly(Return(true));

        int32_t ret = OnRequestDeviceSecLevelInfo(&device, &option, 0, cookie, DslmRequestCallbackMock::MockedCallback);
        EXPECT_EQ(ret, 0);
        mockMsg.MakeDeviceOffline(&device);
    }

    {
        const DeviceIdentify device = {DEVICE_ID_MAX_LEN, {0, 'b', 'c', 'd', 'e', 'f', 'g'}};
        uint32_t cookie = 0xabcd;
        DslmMsgInterfaceMock mockMsg;
        EXPECT_CALL(mockMsg, IsMessengerReady(_)).Times(AtLeast(1));
        EXPECT_CALL(mockMsg, GetSelfDeviceIdentify(_, _, _)).Times(AtLeast(1));
        EXPECT_CALL(mockMsg, SendMsgTo(_, _, _, _, _)).Times(Exactly(0));
        DslmRequestCallbackMock mockCallback;
        auto isRightLevel = [](const DslmCallbackInfo *info) { return info->level >= 1; };
        EXPECT_CALL(mockCallback, RequestCallback(cookie, 0, Truly(isRightLevel))).Times(Exactly(1));

        int32_t ret = OnRequestDeviceSecLevelInfo(&device, &option, 0, cookie, DslmRequestCallbackMock::MockedCallback);
        EXPECT_EQ(ret, 0);
        mockMsg.MakeDeviceOffline(&device);
    }
}

HWTEST_F(DslmTest, OnRequestDeviceSecLevelInfo_case3, TestSize.Level0)
{
    constexpr uint32_t maxNotifySize = 64;

    const DeviceIdentify device = {DEVICE_ID_MAX_LEN, {'a'}};
    const RequestOption option = {
        .challenge = 0xffabcdffffffffee,
        .timeout = 2,
        .extra = 0,
    };

    DslmMsgInterfaceMock mockMsg;
    EXPECT_CALL(mockMsg, IsMessengerReady(_)).Times(AtLeast(1));
    EXPECT_CALL(mockMsg, GetSelfDeviceIdentify(_, _, _)).Times(AtLeast(1));
    EXPECT_CALL(mockMsg, GetDeviceOnlineStatus(_, _, _)).Times(AtLeast(1)).WillRepeatedly(Return(true));
    auto isSendRequestOut = [](const uint8_t *message) {
        const char *prefix = "{\"message\":1,\"payload\":{\"version\":196608,\"challenge\":\"";
        const string msg = string(static_cast<const char *>(static_cast<const void *>(message)));
        EXPECT_EQ(msg.rfind(prefix, 0), 0U);
        return true;
    };

    uint32_t cookie = 0x4567;
    EXPECT_CALL(mockMsg, SendMsgTo(_, _, _, Truly(isSendRequestOut), _)).Times(Exactly(1)).WillRepeatedly(Return(true));

    DslmDeviceInfo *info = CreatOrGetDslmDeviceInfo(&device);
    ASSERT_NE(info, nullptr);

    EXPECT_EQ(info->notifyListSize, 0U);

    DslmRequestCallbackMock callback;
    EXPECT_CALL(callback, RequestCallback(cookie, Ne(0U), Ne(nullptr))).Times(Exactly(maxNotifySize));
    for (uint32_t i = 1; i <= maxNotifySize; i++) {
        int32_t ret = OnRequestDeviceSecLevelInfo(&device, &option, 0, cookie, DslmRequestCallbackMock::MockedCallback);
        EXPECT_EQ(static_cast<uint32_t>(ret), 0U);
        EXPECT_EQ(info->notifyListSize, i);
        EXPECT_EQ(info->historyListSize, 0U);
    }
    for (uint32_t i = 1; i <= maxNotifySize; i++) {
        int32_t ret = OnRequestDeviceSecLevelInfo(&device, &option, 0, cookie, DslmRequestCallbackMock::MockedCallback);
        EXPECT_EQ(static_cast<uint32_t>(ret), ERR_SA_BUSY);
        EXPECT_EQ(info->notifyListSize, maxNotifySize);
        EXPECT_EQ(info->historyListSize, 0U);
    }
    mockMsg.MakeDeviceOffline(&device);

    EXPECT_EQ(info->notifyListSize, 0U);
    EXPECT_EQ(info->historyListSize, 30U); // 30 is the max history list size
}

HWTEST_F(DslmTest, OnRequestDeviceSecLevelInfo_case4, TestSize.Level0)
{
    DslmMsgInterfaceMock mockMsg;
    DslmRequestCallbackMock mockCallback;

    EXPECT_CALL(mockMsg, IsMessengerReady(_)).Times(AtLeast(1));
    EXPECT_CALL(mockMsg, GetDeviceOnlineStatus(_, _, _)).Times(AtLeast(1)).WillRepeatedly(Return(true));
    EXPECT_CALL(mockMsg, SendMsgTo(_, _, _, _, _)).Times(AtLeast(1)).WillRepeatedly(Return(true));
    EXPECT_CALL(mockMsg, GetSelfDeviceIdentify(_, _, _)).Times(AtLeast(1));

    mutex mtx;
    condition_variable cv;
    int32_t cnt = 0;
    const time_point<system_clock> start = system_clock::now();
    const int32_t reqTimes = 3;

    uint32_t cookies[] = {0, 0x1234, 0x5678, 0xabcd};
    uint32_t timeouts[] = {0, 1, 3, 5};

    auto checkCookie = [&mtx, &cv, &cnt, &start, &cookies, &timeouts](uint32_t cookie) {
        unique_lock<mutex> lck(mtx);
        cnt++;
        cv.notify_one();
        time_point<system_clock> curr = system_clock::now();
        auto cost = duration_cast<seconds>(curr - start).count();
        EXPECT_EQ(cookie, cookies[cnt]);
        EXPECT_EQ(cost, timeouts[cnt]);
        return true;
    };

    EXPECT_CALL(mockCallback, RequestCallback(Truly(checkCookie), ERR_TIMEOUT, _)).Times(Exactly(3));

    const DeviceIdentify device = {DEVICE_ID_MAX_LEN, {'a', 'b', 'c', 'd', 'e', 'f', 'a', 'b'}};
    RequestOption option;
    for (int i = 1; i <= reqTimes; i++) {
        option.timeout = timeouts[i];
        int32_t ret =
            OnRequestDeviceSecLevelInfo(&device, &option, i, cookies[i], DslmRequestCallbackMock::MockedCallback);
        EXPECT_EQ(static_cast<uint32_t>(ret), 0U);
    }

    unique_lock<mutex> lck(mtx);
    cv.wait(lck, [&cnt]() { return (cnt == reqTimes); });
    mockMsg.MakeDeviceOffline(&device);
}

HWTEST_F(DslmTest, OnRequestDeviceSecLevelInfo_case5, TestSize.Level0)
{
    const DeviceIdentify device = {DEVICE_ID_MAX_LEN, {'a', 'b', 'c', 'd', 'e', 'f', 'a', 'b'}};
    const RequestOption option = {
        .challenge = 0xffabcdffffffffee,
        .timeout = 2,
        .extra = 0,
    };
    uint32_t cookie = 1234;

    int32_t ret = OnRequestDeviceSecLevelInfo(&device, &option, 0, cookie, nullptr);
    EXPECT_EQ(ERR_INVALID_PARA, ret);
}

HWTEST_F(DslmTest, OnPeerMsgRequestInfoReceived_case1, TestSize.Level0)
{
    const char *input = "{\"version\":65536,\"challenge\":\"0102030405060708\"}";
    uint32_t len = strlen(input) + 1;

    const DeviceIdentify device = {DEVICE_ID_MAX_LEN, {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i'}};

    (void)OnPeerMsgRequestInfoReceived(&device, (const uint8_t *)input, len);

    int32_t ret = OnPeerMsgRequestInfoReceived(&device, nullptr, len);
    EXPECT_EQ(ERR_INVALID_PARA, ret);

    len = 0;
    ret = OnPeerMsgRequestInfoReceived(&device, (const uint8_t *)input, len);
    EXPECT_EQ(ERR_INVALID_PARA, ret);
}

HWTEST_F(DslmTest, OnPeerMsgRequestInfoReceived_case2, TestSize.Level0)
{
    const DeviceIdentify *device = nullptr;
    const char *input = "{\"version\":65536,\"challenge\":\"0102030405060708\"}";
    uint32_t len = strlen(input) + 1;

    int32_t ret = OnPeerMsgRequestInfoReceived(device, (const uint8_t *)input, len);
    EXPECT_EQ(ERR_INVALID_PARA, ret);
}

HWTEST_F(DslmTest, OnPeerMsgResponseInfoReceived_case1, TestSize.Level0)
{
    const char *input = "{\"version\":65536,\"type\":0,\"challenge\":\"EEFFFFFFFFCDABFF\",\"info\":"
                        "\"MDAwMTAyMDMwNDA1MDYwNzA4MDkwQTBCMEMwRDBFMEYxMDExMTIxMzE0MTUxNkFBQkJDQ0RE\"}";
    uint32_t len = strlen(input) + 1;

    DeviceIdentify device = {8, {'a', 'b', 'c', 'd', 'e', 'f', 'g'}};

    int32_t ret = OnPeerMsgResponseInfoReceived(&device, (const uint8_t *)input, len);
    EXPECT_EQ(ERR_NOEXIST_DEVICE, static_cast<int32_t>(ret));

    ret = OnPeerMsgResponseInfoReceived(&device, nullptr, len);
    EXPECT_EQ(ERR_INVALID_PARA, ret);

    len = 0;
    ret = OnPeerMsgResponseInfoReceived(&device, (const uint8_t *)input, len);
    EXPECT_EQ(ERR_INVALID_PARA, ret);
}

HWTEST_F(DslmTest, OnPeerMsgResponseInfoReceived_case2, TestSize.Level0)
{
    const DeviceIdentify *device = nullptr;
    const char *input = "{\"version\":65536,\"challenge\":\"0102030405060708\"}";
    uint32_t len = strlen(input) + 1;

    int32_t ret = OnPeerMsgResponseInfoReceived(device, (const uint8_t *)input, len);
    EXPECT_EQ(ERR_INVALID_PARA, ret);
}

HWTEST_F(DslmTest, InitSelfDeviceSecureLevel_case1, TestSize.Level0)
{
    const DeviceIdentify device = {DEVICE_ID_MAX_LEN, {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i'}};
    DslmDeviceInfo *info = GetDslmDeviceInfo(&device);
    EXPECT_EQ(nullptr, info);

    DslmMsgInterfaceMock mockMsg;
    mockMsg.MakeSelfDeviceId(&device);
    mockMsg.MakeMsgLoopback();
    EXPECT_CALL(mockMsg, GetSelfDeviceIdentify(_, _, _)).Times(AtLeast(1));
    InitSelfDeviceSecureLevel();

    info = GetDslmDeviceInfo(&device);
    ASSERT_NE(nullptr, info);
    EXPECT_GE(info->credInfo.credLevel, 1U);
    mockMsg.MakeDeviceOffline(&device);
}

HWTEST_F(DslmTest, InitSelfDeviceSecureLevel_case2, TestSize.Level0)
{
    const DeviceIdentify device = {DEVICE_ID_MAX_LEN, {'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x'}};

    DslmDeviceInfo *info = GetDslmDeviceInfo(&device);
    EXPECT_EQ(nullptr, info);

    DslmMsgInterfaceMock mockMsg;
    EXPECT_CALL(mockMsg, SendMsgTo(_, _, _, _, _)).Times(Exactly(6));
    mockMsg.MakeDeviceOnline(&device);

    info = GetDslmDeviceInfo(&device);
    ASSERT_NE(nullptr, info);
    EXPECT_EQ(1U, info->queryTimes);
    EXPECT_EQ(STATE_WAITING_CRED_RSP, info->machine.currState);

    BlockCheckDeviceStatus(&device, STATE_SUCCESS, 5000);
    EXPECT_EQ(STATE_FAILED, info->machine.currState);
    EXPECT_LT(5U, info->queryTimes);
    mockMsg.MakeDeviceOffline(&device);
}

HWTEST_F(DslmTest, InnerKitsTest_case1, TestSize.Level0)
{
    DeviceIdentify device = {DEVICE_ID_MAX_LEN, {0}};

    DeviceSecurityInfo *info = nullptr;
    int32_t ret = RequestDeviceSecurityInfo(&device, nullptr, &info);
    EXPECT_EQ(ret, 0);
    int32_t level = 0;
    ret = GetDeviceSecurityLevelValue(info, &level);
    FreeDeviceSecurityInfo(info);
    EXPECT_EQ(ret, 0);
    EXPECT_GE(level, 1);
}

static int32_t g_cnt = 0;
static mutex g_mtx;
static condition_variable g_cv;

void TestDeviceSecurityInfoCallback(const DeviceIdentify *identify, struct DeviceSecurityInfo *info)
{
    unique_lock<mutex> lck(g_mtx);
    int32_t level = 0;
    int32_t ret = GetDeviceSecurityLevelValue(info, &level);
    FreeDeviceSecurityInfo(info);
    EXPECT_EQ(ret, 0);
    EXPECT_GE(level, 1);
    g_cnt++;
    g_cv.notify_one();
}

HWTEST_F(DslmTest, InnerKitsTest_case2, TestSize.Level0)
{
    DeviceIdentify device = {DEVICE_ID_MAX_LEN, {0}};

    g_cnt = 0;
    int ret = RequestDeviceSecurityInfoAsync(&device, nullptr, TestDeviceSecurityInfoCallback);
    EXPECT_EQ(ret, 0);

    ret = RequestDeviceSecurityInfoAsync(&device, nullptr, TestDeviceSecurityInfoCallback);
    EXPECT_EQ(ret, 0);

    ret = RequestDeviceSecurityInfoAsync(&device, nullptr, TestDeviceSecurityInfoCallback);
    EXPECT_EQ(ret, 0);

    unique_lock<mutex> lck(g_mtx);
    g_cv.wait_for(lck, std::chrono::milliseconds(2000), []() { return (g_cnt == 3); });
    EXPECT_EQ(g_cnt, 3);
}

HWTEST_F(DslmTest, InnerKitsTest_case3, TestSize.Level0)
{
    DeviceIdentify device = {DEVICE_ID_MAX_LEN, {0}};
    (void)memset_s(device.identity, DEVICE_ID_MAX_LEN, 'F', DEVICE_ID_MAX_LEN);
    DeviceSecurityInfo *info = nullptr;
    int32_t ret = RequestDeviceSecurityInfo(&device, nullptr, &info);
    EXPECT_EQ(ret, ERR_NOEXIST_DEVICE);
}

HWTEST_F(DslmTest, GetSupportedCredTypes_case1, TestSize.Level0)
{
    int32_t ret = GetSupportedCredTypes(nullptr, 0);
    EXPECT_EQ(0, ret);
}

/**
 * @tc.name: GetSupportedCredTypes_case2
 * @tc.desc: function GetSupportedCredTypes with malformed inputs
 * @tc.type: FUNC
 * @tc.require: issueNumber
 */
HWTEST_F(DslmTest, GetSupportedCredTypes_case2, TestSize.Level0)
{
    int32_t ret;
    CredType list[] = {CRED_TYPE_MINI, CRED_TYPE_SMALL, CRED_TYPE_STANDARD, CRED_TYPE_LARGE};
    ret = GetSupportedCredTypes(list, 2);
    EXPECT_EQ(2, ret);

    ret = GetSupportedCredTypes(list, 0);
    EXPECT_EQ(0, ret);
}

HWTEST_F(DslmTest, CreateDslmCred_case1, TestSize.Level0)
{
    CredType type = CRED_TYPE_STANDARD;

    EXPECT_EQ(nullptr, CreateDslmCred(type, 0, nullptr));
}

HWTEST_F(DslmTest, CreateDslmCred_case2, TestSize.Level0)
{
    uint8_t buff[BUFF_LEN];
    memset_s(buff, sizeof(buff), 'c', sizeof(buff));
    TlvCommon *ptr = (TlvCommon *)buff;
    ptr->tag = 0x110;
    ptr->len = PTR_LEN;
    CredType type = CRED_TYPE_STANDARD;

    EXPECT_EQ(nullptr, CreateDslmCred(type, 0, buff));

    EXPECT_EQ(nullptr, CreateDslmCred(type, MAX_CRED_LEN + 1, buff));
}

HWTEST_F(DslmTest, CheckAndGenerateChallenge_case1, TestSize.Level0)
{
    DslmDeviceInfo device;
    (void)memset_s(&device, sizeof(DslmDeviceInfo), 0, sizeof(DslmDeviceInfo));

    {
        int32_t ret = CheckAndGenerateChallenge(nullptr);
        EXPECT_EQ(ERR_INVALID_PARA, ret);
    }

    {
        int32_t ret = CheckAndGenerateChallenge(&device);
        EXPECT_EQ(SUCCESS, ret);
    }
}

HWTEST_F(DslmTest, CheckAndGenerateChallenge_case2, TestSize.Level0)
{
    DslmDeviceInfo device;
    (void)memset_s(&device, sizeof(DslmDeviceInfo), 0, sizeof(DslmDeviceInfo));

    {
        device.nonceTimeStamp = 0xFFFFFFFFFFFFFFFF;
        int32_t ret = CheckAndGenerateChallenge(&device);
        EXPECT_EQ(SUCCESS, ret);
    }

    {
        device.nonceTimeStamp = GetMillisecondSinceBoot();
        int32_t ret = CheckAndGenerateChallenge(&device);
        EXPECT_EQ(SUCCESS, ret);
    }

    {
        device.nonceTimeStamp = GetMillisecondSinceBoot();
        device.nonce = 1;
        int32_t ret = CheckAndGenerateChallenge(&device);
        EXPECT_EQ(SUCCESS, ret);
    }
}

HWTEST_F(DslmTest, SendDeviceInfoRequest_case1, TestSize.Level0)
{
    DslmDeviceInfo *device = nullptr;

    int32_t ret = SendDeviceInfoRequest(device);
    EXPECT_EQ(ERR_INVALID_PARA, ret);
}

HWTEST_F(DslmTest, VerifyDeviceInfoResponse_case1, TestSize.Level0)
{
    DslmDeviceInfo *device = nullptr;

    int32_t ret = VerifyDeviceInfoResponse(device, NULL);
    EXPECT_EQ(ERR_INVALID_PARA, ret);
}

HWTEST_F(DslmTest, VerifyDeviceInfoResponse_case2, TestSize.Level0)
{
    MessageBuff msg = {.length = 0, .buff = nullptr};
    DslmDeviceInfo device;
    (void)memset_s(&device, sizeof(device), 0, sizeof(device));

    int32_t ret = VerifyDeviceInfoResponse(&device, &msg);
    EXPECT_EQ(ERR_INVALID_PARA, ret);

    ret = VerifyDeviceInfoResponse(&device, nullptr);
    EXPECT_EQ(ERR_INVALID_PARA, ret);
}

HWTEST_F(DslmTest, VerifyDeviceInfoResponse_case3, TestSize.Level0)
{
    const char *message = "{\"version\":131072,\"challenge\":\"3C1F21EE53D3C4E2\",\"type\":2,\"info\":"
                          "\"SkFERS1BTDAwOjg3QUQyOEQzQjFCLi4u\"}";
    uint32_t messageLen = strlen(message) + 1;
    MessageBuff msg = {.length = messageLen, .buff = (uint8_t *)message};

    DslmDeviceInfo device;
    (void)memset_s(&device, sizeof(device), 0, sizeof(device));

    int32_t ret = VerifyDeviceInfoResponse(&device, &msg);
    EXPECT_EQ(ERR_CHALLENGE_ERR, ret);
}

HWTEST_F(DslmTest, VerifyDeviceInfoResponse_case4, TestSize.Level0)
{
    DslmDeviceInfo device;
    memset_s(&device, sizeof(DslmDeviceInfo), 0, sizeof(DslmDeviceInfo));
    device.nonce = 0xE2C4D353EE211F3C;
    const char *message = "{\"version\":131072,\"challenge\":\"3C1F21EE53D3C4E2\",\"type\":2,\"info\":"
                          "\"SkFERS1BTDAwOjg3QUQyOEQzQjFCLi4u\"}";
    uint32_t messageLen = strlen(message) + 1;
    MessageBuff msg = {.length = messageLen, .buff = (uint8_t *)message};

    {
        int32_t ret = VerifyDeviceInfoResponse(&device, &msg);
        EXPECT_EQ(ERR_CHALLENGE_ERR, ret);
    }

    {
        device.nonceTimeStamp = 0xFFFFFFFFFFFFFFFF;
        int32_t ret = VerifyDeviceInfoResponse(&device, &msg);
        EXPECT_EQ(ERR_CHALLENGE_ERR, ret);
    }
}

HWTEST_F(DslmTest, GetDslmDeviceInfo_case1, TestSize.Level0)
{
    DeviceIdentify *device = nullptr;

    EXPECT_EQ(nullptr, GetDslmDeviceInfo(device));
}

HWTEST_F(DslmTest, CreatOrGetDslmDeviceInfo_case1, TestSize.Level0)
{
    DeviceIdentify *device = nullptr;

    EXPECT_EQ(nullptr, CreatOrGetDslmDeviceInfo(device));
}

HWTEST_F(DslmTest, CreatOrGetDslmDeviceInfo_case2, TestSize.Level0)
{
    DeviceIdentify device = {.length = DEVICE_ID_MAX_LEN - 1};

    EXPECT_EQ(nullptr, CreatOrGetDslmDeviceInfo(&device));
}

HWTEST_F(DslmTest, IsSameDevice_case1, TestSize.Level0)
{
    DeviceIdentify *device_first = nullptr;
    DeviceIdentify device_second;
    (void)memset_s(&device_second, sizeof(device_second), 0, sizeof(device_second));

    EXPECT_EQ(false, IsSameDevice(device_first, &device_second));

    EXPECT_EQ(false, IsSameDevice(&device_second, nullptr));
}

HWTEST_F(DslmTest, GetCurrentMachineState_case1, TestSize.Level0)
{
    DslmDeviceInfo *info = nullptr;
    uint32_t ret = GetCurrentMachineState(info);
    EXPECT_EQ(STATE_FAILED, ret);
}

HWTEST_F(DslmTest, OnMsgSendResultNotifier_case1, TestSize.Level0)
{
    DeviceIdentify identify = {DEVICE_ID_MAX_LEN, {'a', 'b', 'c', 'd', 'e', 'f', 'a', 'b'}};
    uint64_t transNo = 0;
    uint32_t result = ERR_DEFAULT;

    {
        uint32_t ret = OnMsgSendResultNotifier(&identify, transNo, result);
        EXPECT_EQ(SUCCESS, ret);
    }

    {
        uint32_t ret = OnMsgSendResultNotifier(nullptr, transNo, result);
        EXPECT_EQ(SUCCESS, ret);
    }
}

HWTEST_F(DslmTest, OnPeerStatusReceiver_case1, TestSize.Level0)
{
    const DeviceIdentify device = {DEVICE_ID_MAX_LEN, {'a', 'b', 'c', 'd', 'e', 'f', 'a', 'b'}};
    uint32_t status = 1234;
    uint32_t level = -1;

    int32_t ret = OnPeerStatusReceiver(&device, status, level);
    EXPECT_EQ(SUCCESS, ret);
}

HWTEST_F(DslmTest, InitDslmProcess_case1, TestSize.Level0)
{
    EXPECT_EQ(false, InitDslmProcess());
}

HWTEST_F(DslmTest, DeinitDslmProcess_case1, TestSize.Level0)
{
    EXPECT_EQ(true, DeinitDslmProcess());
}

// dslm_ohos_verify.c
HWTEST_F(DslmTest, VerifyOhosDslmCred_case1, TestSize.Level0)
{
    const DeviceIdentify device = {DEVICE_ID_MAX_LEN, {'a', 'b', 'c', 'd', 'e', 'f', 'a', 'b'}};
    uint64_t challenge = 0x1234;
    uint8_t info[] = {'a', 'b', 'c', 'd', 1, 3, 5, 7, 9};
    DslmCredBuff cred = {CRED_TYPE_STANDARD, 9, info};
    DslmCredInfo *credInfo = nullptr;

    int32_t ret = VerifyOhosDslmCred(&device, challenge, &cred, credInfo);
    EXPECT_EQ(ERR_INVALID_PARA, ret);
}

HWTEST_F(DslmTest, VerifyOhosDslmCred_case2, TestSize.Level0)
{
    const DeviceIdentify device = {DEVICE_ID_MAX_LEN, {'a', 'b', 'c', 'd', 'e', 'f', 'a', 'b'}};
    uint64_t challenge = 0x1234;
    uint8_t info[] = {'a', 'b', 'c', 'd', 1, 3, 5, 7, 9};
    DslmCredBuff cred = {CRED_TYPE_LARGE, 9, info};
    DslmCredInfo credInfo;
    (void)memset_s(&credInfo, sizeof(DslmCredInfo), 0, sizeof(DslmCredInfo));

    int32_t ret = VerifyOhosDslmCred(&device, challenge, &cred, &credInfo);
    EXPECT_EQ(ERR_INVALID_PARA, ret);

    ret = VerifyOhosDslmCred(nullptr, challenge, &cred, &credInfo);
    EXPECT_EQ(ERR_INVALID_PARA, ret);

    ret = VerifyOhosDslmCred(&device, challenge, nullptr, &credInfo);
    EXPECT_EQ(ERR_INVALID_PARA, ret);
}

HWTEST_F(DslmTest, VerifyOhosDslmCred_case3, TestSize.Level0)
{
    const DeviceIdentify device = {DEVICE_ID_MAX_LEN, {'a', 'b', 'c', 'd', 'e', 'f', 'a', 'b'}};
    uint64_t challenge = 0x1234;
    uint8_t info[] = {'a', 'b', 'c', 'd', 1, 3, 5, 7, 9};
    DslmCredBuff cred = {CRED_TYPE_SMALL, 9, info};
    DslmCredInfo credInfo;
    (void)memset_s(&credInfo, sizeof(DslmCredInfo), 0, sizeof(DslmCredInfo));

    int32_t ret = VerifyOhosDslmCred(&device, challenge, &cred, &credInfo);
    EXPECT_EQ(ERR_PARSE_CLOUD_CRED_DATA, ret);
}

// dslm_ohos_request.c

// 2nd param of GetCredFromCurrentDevice() is 0
HWTEST_F(DslmTest, GetCredFromCurrentDevice_case1, TestSize.Level0)
{
    char cred[] = "test";
    uint32_t len = 0;

    int32_t ret = GetCredFromCurrentDevice(cred, len);
    EXPECT_EQ(ERR_INVALID_PARA, ret);

    ret = GetCredFromCurrentDevice(nullptr, len);
    EXPECT_EQ(ERR_INVALID_PARA, ret);
}

/**
 * @tc.name: GetPeerDeviceOnlineStatus_case1
 * @tc.desc: function GetPeerDeviceOnlineStatus when g_messenger is NULL
 * @tc.type: FUNC
 * @tc.require: issueNumber
 */
HWTEST_F(DslmTest, GetPeerDeviceOnlineStatus_case1, TestSize.Level0)
{
    EXPECT_EQ(false, GetPeerDeviceOnlineStatus(nullptr, nullptr));
}

/**
 * @tc.name: GetPeerDeviceOnlineStatus_case2
 * @tc.desc: function GetPeerDeviceOnlineStatus with null input
 * @tc.type: FUNC
 * @tc.require: issueNumber
 */
HWTEST_F(DslmTest, GetPeerDeviceOnlineStatus_case2, TestSize.Level0)
{
    DslmMsgInterfaceMock mockMsg;
    EXPECT_EQ(false, GetPeerDeviceOnlineStatus(nullptr, nullptr));
}

/**
 * @tc.name: GetSelfDevice_case1
 * @tc.desc: function GetSelfDevice with null input
 * @tc.type: FUNC
 * @tc.require: issueNumber
 */
HWTEST_F(DslmTest, GetSelfDevice_case1, TestSize.Level0)
{
    int32_t level = 0;
    const DeviceIdentify *identify = GetSelfDevice(&level);
    EXPECT_NE(nullptr, identify);
}

/**
 * @tc.name: DeinitMessenger_case1
 * @tc.desc: function DeinitMessenger when g_messenger is NULL
 * @tc.type: FUNC
 * @tc.require: issueNumber
 */
HWTEST_F(DslmTest, DeinitMessenger_case1, TestSize.Level0)
{
    DslmMsgInterfaceMock mockMsg;

    uint32_t ret = DeinitMessenger();
    EXPECT_EQ(SUCCESS, ret);
}

/**
 * @tc.name: DeinitMessenger_case2
 * @tc.desc: function DeinitMessenger when g_messenger is not NULL
 * @tc.type: FUNC
 * @tc.require: issueNumber
 */
HWTEST_F(DslmTest, DeinitMessenger_case2, TestSize.Level0)
{
    uint32_t ret = DeinitMessenger();
    EXPECT_EQ(SUCCESS, ret);
}

/**
 * @tc.name: SendMsgToDevice_case1
 * @tc.desc: function SendMsgToDevice when g_messenger is NULL
 * @tc.type: FUNC
 * @tc.require: issueNumber
 */
HWTEST_F(DslmTest, SendMsgToDevice_case1, TestSize.Level0)
{
    DslmMsgInterfaceMock mockMsg;
    uint64_t transNo = 0xfe;
    const DeviceIdentify devId = {DEVICE_ID_MAX_LEN, {0}};
    const uint8_t msg[] = {'1', '2'};
    uint32_t msgLen = 2;

    mockMsg.~DslmMsgInterfaceMock();
    EXPECT_CALL(mockMsg, SendMsgTo(_, _, _, _, _)).Times(Exactly(0));

    SendMsgToDevice(transNo, &devId, msg, msgLen);
}

/**
 * @tc.name: CheckMessage_case1
 * @tc.desc: function CheckMessage when malformed input,
 *           msg contains non ASCII item.
 * @tc.type: FUNC
 * @tc.require: issueNumber
 */
HWTEST_F(DslmTest, CheckMessage_case1, TestSize.Level0)
{
    const uint8_t msg[] = {'1', 0x8f, '\0'};
    uint32_t msgLen = 3;

    EXPECT_EQ(false, CheckMessage(msg, msgLen));
}

// just for coverage
/**
 * @tc.name: FreeMessagePacket_case1
 * @tc.desc: function FreeMessagePacket when packet->payload is NULL
 * @tc.type: FUNC
 * @tc.require: issueNumber
 */
HWTEST_F(DslmTest, FreeMessagePacket_case1, TestSize.Level0)
{
    MessagePacket *packet = (MessagePacket *)MALLOC(sizeof(MessagePacket));
    ASSERT_NE(nullptr, packet);
    (void)memset_s(packet, sizeof(MessagePacket), 0, sizeof(MessagePacket));

    FreeMessagePacket(packet);
}

// just for coverage
/**
 * @tc.name: FreeMessageBuff_case1
 * @tc.desc: function FreeMessageBuff when buff->buff is NULL
 * @tc.type: FUNC
 * @tc.require: issueNumber
 */
HWTEST_F(DslmTest, FreeMessageBuff_case1, TestSize.Level0)
{
    MessageBuff *buff = (MessageBuff *)MALLOC(sizeof(MessageBuff));
    ASSERT_NE(nullptr, buff);
    memset_s(buff, sizeof(MessageBuff), 0, sizeof(MessageBuff));

    FreeMessageBuff(buff);
    FreeMessageBuff(nullptr);
}

static void dummyDump(const DslmDeviceInfo *info, int32_t fd)
{
    (void)info;
    (void)fd;
}

HWTEST_F(DslmTest, ForEachDeviceDump_case1, TestSize.Level0)
{
    ForEachDeviceDump(nullptr, 0);
    ForEachDeviceDump(dummyDump, 0);
    InitDslmStateMachine(nullptr);
    ScheduleDslmStateMachine(nullptr, 0, nullptr);
}

/**
 * @tc.name: DestroyDslmCred_case1
 * @tc.desc: function DestroyDslmCred with malformed inputs
 * @tc.type: FUNC
 * @tc.require: issueNumber
 */
HWTEST_F(DslmTest, DestroyDslmCred_case1, TestSize.Level0)
{
    DslmCredBuff *cred = (DslmCredBuff *)MALLOC(sizeof(DslmCredBuff));
    cred->type = (CredType)3;
    cred->credLen = 9;
    cred->credVal = nullptr;
    DestroyDslmCred(cred);

    cred = nullptr;
    DestroyDslmCred(cred);
    EXPECT_EQ(nullptr, cred);
}

/**
 * @tc.name: ReportHiEventAppInvoke_case1
 * @tc.desc: function ReportHiEventAppInvoke with malformed inputs
 * @tc.type: FUNC
 * @tc.require: issueNumber
 */
HWTEST_F(DslmTest, ReportHiEventAppInvoke_case1, TestSize.Level0)
{
    DslmDeviceInfo *info = (DslmDeviceInfo *)MALLOC(sizeof(DslmDeviceInfo));
    ASSERT_NE(nullptr, info);
    (void)memset_s(info, sizeof(DslmDeviceInfo), 0, sizeof(DslmDeviceInfo));
    info->lastRequestTime = 10U;
    ReportHiEventInfoSync(nullptr);
    ReportHiEventInfoSync(info);
    ReportHiEventAppInvoke(nullptr);
    EXPECT_NE(nullptr, info);
    FREE(info);
    info = nullptr;
}

/**
 * @tc.name: GetDeviceSecurityLevelValue_case1
 * @tc.desc: function GetDeviceSecurityLevelValue with malformed inputs
 * @tc.type: FUNC
 * @tc.require: issueNumber
 */
HWTEST_F(DslmTest, GetDeviceSecurityLevelValue_case1, TestSize.Level0)
{
    int32_t ret;
    int32_t level = 0;
    DeviceSecurityInfo info = {.magicNum = 0xcd, .result = 0, .level = 0};

    ret = GetDeviceSecurityLevelValue(nullptr, &level);
    EXPECT_EQ(ERR_INVALID_PARA, ret);

    ret = GetDeviceSecurityLevelValue(&info, nullptr);
    EXPECT_EQ(ERR_INVALID_PARA, ret);
}

/**
 * @tc.name: RequestDeviceSecurityInfoAsync_case1
 * @tc.desc: function RequestDeviceSecurityInfoAsync with malformed inputs
 * @tc.type: FUNC
 * @tc.require: issueNumber
 */
HWTEST_F(DslmTest, RequestDeviceSecurityInfoAsync_case1, TestSize.Level0)
{
    int32_t ret;
    const DeviceIdentify device = {DEVICE_ID_MAX_LEN, {'a', 'b', 'c', 'd', 'e', 'f', 'g'}};
    RequestOption opt = {.challenge = 0xcd, .timeout = 400, .extra = 0};
    auto callback = [](const DeviceIdentify *identify, struct DeviceSecurityInfo *info) { return; };

    ret = RequestDeviceSecurityInfoAsync(nullptr, &opt, callback);
    EXPECT_EQ(ERR_INVALID_PARA, ret);

    ret = RequestDeviceSecurityInfoAsync(&device, &opt, nullptr);
    EXPECT_EQ(ERR_INVALID_PARA, ret);

    // malformed option->timeout > MAX_KEEP_LEN
    ret = RequestDeviceSecurityInfoAsync(&device, &opt, callback);
    EXPECT_EQ(ERR_INVALID_PARA, ret);
}

HWTEST_F(DslmTest, DslmDumper_case1, TestSize.Level0)
{
    DslmDumper(-1);
}

HWTEST_F(DslmTest, CreateQueueMsgData_case1, TestSize.Level0)
{
    const DeviceIdentify device = {DEVICE_ID_MAX_LEN, {'a', 'b', 'c', 'd', 'e', 'f', 'g'}};
    const uint8_t msg[] = {'1', '2'};
    uint32_t msgLen = 0;
    uint32_t queueDataLen = 0;

    EXPECT_EQ(nullptr, CreateQueueMsgData(&device, msg, msgLen, &queueDataLen));

    EXPECT_EQ(nullptr, CreateQueueMsgData(nullptr, msg, msgLen, &queueDataLen));

    EXPECT_EQ(nullptr, CreateQueueMsgData(&device, nullptr, msgLen, &queueDataLen));

    msgLen = 2;
    EXPECT_EQ(nullptr, CreateQueueMsgData(&device, msg, msgLen, nullptr));

    (void)CreateQueueMsgData(&device, msg, msgLen, &queueDataLen);
}

HWTEST_F(DslmTest, CreateMessenger_case1, TestSize.Level0)
{
    MessengerConfig config = {
        .pkgName = GetMessengerPackageName(),
        .primarySockName = GetMessengerPrimarySessionName(),
        .secondarySockName = GetMessengerSecondarySessionName(),
        .messageReceiver = OnPeerMsgReceived,
        .statusReceiver = OnPeerStatusReceiver,
        .sendResultNotifier = OnSendResultNotifier,
    };

    WorkQueue *processQueue = CreateWorkQueue(MESSENGER_PROCESS_QUEUE_SIZE, MESSENGER_PROCESS_QUEUE_NAME);

    bool result = InitDeviceSocketManager(processQueue, &config);

    EXPECT_EQ(false, InitDeviceSocketManager(nullptr, &config));

    EXPECT_EQ(false, InitDeviceSocketManager(processQueue, nullptr));

    result = InitDeviceStatusManager(processQueue, config.pkgName, config.statusReceiver);

    EXPECT_EQ(false, InitDeviceStatusManager(nullptr, config.pkgName, config.statusReceiver));

    EXPECT_EQ(false, InitDeviceStatusManager(processQueue, nullptr, config.statusReceiver));

    EXPECT_EQ(false, InitDeviceStatusManager(processQueue, config.pkgName, nullptr));
}

HWTEST_F(DslmTest, MessengerSendMsgTo_case1, TestSize.Level0)
{
    uint64_t transNo = 0xfe;
    const DeviceIdentify device = {DEVICE_ID_MAX_LEN, {0}};
    const uint8_t msg[] = {'1', '2'};
    uint32_t msgLen = 2;

    MessengerSendMsgTo(transNo, &device, msg, msgLen);

    MessengerSendMsgTo(transNo, nullptr, msg, msgLen);

    MessengerSendMsgTo(transNo, &device, nullptr, msgLen);

    MessengerSendMsgTo(transNo, &device, msg, 0);

    MessengerSendMsgTo(transNo, &device, msg, MSG_BUFF_MAX_LENGTH + 1);
}

HWTEST_F(DslmTest, MessengerGetDeviceIdentifyByNetworkId_case1, TestSize.Level0)
{
    const char networkId[] = {'1', '2'};
    DeviceIdentify device = {DEVICE_ID_MAX_LEN, {0}};

    EXPECT_EQ(false, MessengerGetDeviceIdentifyByNetworkId(networkId, &device));

    EXPECT_EQ(false, MessengerGetDeviceIdentifyByNetworkId(nullptr, &device));

    EXPECT_EQ(false, MessengerGetDeviceIdentifyByNetworkId(networkId, nullptr));
}

HWTEST_F(DslmTest, MessengerGetNetworkIdByDeviceIdentify_case1, TestSize.Level0)
{
    char networkId[DEVICE_ID_MAX_LEN + 1] = {0};
    const DeviceIdentify device = {DEVICE_ID_MAX_LEN, {0}};
    uint32_t len = 0;

    EXPECT_EQ(false, MessengerGetNetworkIdByDeviceIdentify(&device, networkId, len));

    EXPECT_EQ(false, MessengerGetNetworkIdByDeviceIdentify(nullptr, networkId, len));

    EXPECT_EQ(false, MessengerGetNetworkIdByDeviceIdentify(&device, nullptr, len));
}

HWTEST_F(DslmTest, MessengerGetSelfDeviceIdentify_case1, TestSize.Level0)
{
    DeviceIdentify device = {DEVICE_ID_MAX_LEN, {0}};

    EXPECT_EQ(false, MessengerGetSelfDeviceIdentify(nullptr, nullptr));

    EXPECT_EQ(false, MessengerGetSelfDeviceIdentify(&device, nullptr));
}
} // namespace DslmUnitTest
} // namespace Security
} // namespace OHOS